[{"content":" 环境清理 1 2 3 4 5 6 7 8 9 10 11 12 13  #删除现有Python ##强制删除已安装程序及其关联 rpm -qa|grep python|xargs rpm -ev --allmatches --nodeps ##删除所有残余文件 ##xargs，允许你对输出执行其他某些命令 whereis python |xargs rm -frv ##验证删除，返回无结果 whereis python #删除现有的yum、强制删除已安装程序及其关联 ##强制删除已安装程序及其关联 rpm -qa|grep yum|xargs rpm -ev --allmatches --nodeps ##强制删除所有残余文件 whereis yum |xargs rm -frv   修复 Python2 1.下载相应的包\n1 2 3 4 5 6 7 8 9 10 11 12  #查看自己系统版本的命令 cat /etc/redhat-release #CentOS Linux release 7.8.2003 (Core) #下载地址 http://mirrors.ustc.edu.cn/centos/7.8.2003(自己系统版本号)/os/x86_64/Packages/  #python 相应版本号按最新的来 python-2.7.5-88.el7.x86_64.rpm python-iniparse-0.4-9.el7.noarch.rpm python-pycurl-7.19.0-19.el7.x86_64.rpm python-devel-2.7.5-88.el7.x86_64.rpm python-libs-2.7.5-88.el7.x86_64.rpm python-urlgrabber-3.10-10.el7.noarch.rpm rpm-python-4.11.3-43.el7.x86_64.rpm   2.安装\n1 2 3 4 5 6 7 8 9  #安装python cd /usr/local/rpm rpm -ivh python-* rpm-python-* #出现安装包的依赖问题，此时如下解决即可：--nodeps --force为不考虑依赖包，强制安装。 rpm -ivh python-* rpm-python-* --nodeps --force #验证python Python 2.7.5 (default,Nov 20 2020,21:18:26)   修复 yum 1.下载相应的包\n1 2 3 4 5 6 7 8 9 10 11 12 13  #查看自己系统版本的命令 cat /etc/redhat-release #CentOS Linux release 7.8.2003 (Core) #下载相应的包地址： http://mirrors.ustc.edu.cn/centos/7.8.2003(自己系统版本号)/os/x86_64/Packages/ #下载下列需要的包 yum-3.4.3-167.el7.centos.noarch.rpm yum-metadata-parser-1.1.4-10.el7.x86_64.rpm yum-plugin-fastestmirror-1.1.31-53.el7.noarch.rpm #创建目录python和yum用以存放rpm包 mkdir /usr/local/rpm    2.安装\n1 2 3 4 5 6 7  #安装yum rpm -ivh yum-* #生成缓存 yum clean all yum makecache yum update  ","permalink":"https://byteprince.com/posts/0142f245/","summary":"使用root权限一定要小心","title":"CentOS 同时误删 yum 和 Python2 的解决办法"},{"content":"深圳高新富悦酒店俯瞰\n深圳大学门口的天桥上拍摄\n深圳大学门口的天桥\n腾讯大厦边上的一个报刊亭\n深圳大学门口\n深圳大学边上的公交站\n","permalink":"https://byteprince.com/posts/111d8d65/","summary":"赴深圳参加培训","title":"深圳之行"},{"content":"📕简明教程 进入容器 1  docker exec -it 容器ID /bin/bash   常用命令  ❖ task \u0026lt;name/path\u0026gt; ✧ 延迟执行，如果设置了随机延迟并且当时时间不在0-2、30-31、59分内，将随机延迟一定秒数 ❖ task \u0026lt;name/path\u0026gt; now ✧ 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出内容，同时记录在日志文件中 ❖ task \u0026lt;name/path\u0026gt; conc ✧ 并发执行，无论是否设置了随机延迟，均立即运行，前台不输出内容，直接记录在日志文件中 ❖ task \u0026lt;name/path\u0026gt; \u0026lt;num\u0026gt; ✧ 指定执行，指定某账号单独运行脚本，num 为某 Cookie 账号在配置文件中的具体编号 ❖ task \u0026lt;name/path\u0026gt; pkill ✧ 终止执行，根据脚本名称搜索对应的进程并立即杀死，当脚本报错死循环时可使用此功能 ❖ task \u0026lt;name\u0026gt; rapid ✧ 迅速执行，不组合互助码等步骤最大化降低执行前耗时，可选参数(加在末尾): -c 并发 ❖ task \u0026lt;url\u0026gt; raw ✧ 远程执行，拉取远程仓库的脚本后执行，可选参数(加在末尾): -p 代理、-c 并发 ❖ source runall ✧ 全部执行，通过交互选择运行模式执行指定范围的脚本，非常耗时不要盲目使用 ❖ task list ✧ 查看本地脚本清单 ❖ task ps ✧ 查看资源消耗情况和正在运行的脚本进程，当检测到内存占用较高时自动尝试释放 ❖ task exsc ✧ 导出互助码变量和助力格式，互助码从最后一个日志提取，受日志内容影响 ❖ task rmlog ✧ 删除各脚本产生的日志文件，可根据配置文件中的相关变量定义删除日期 ❖ task cookie \u0026lt;cmd\u0026gt; ✧ 检测本地账号是否有效 check、使用 WSKEY 更新COOKIE update，支持指定账号进行更新 ❖ taskctl server status ✧ 查看各服务的详细信息，包括运行状态、创建时间、处理器占用、内存占用、运行时长 ❖ taskctl hang \u0026lt;cmd\u0026gt; ✧ 后台挂机程序(后台循环执行活动脚本)功能控制，启动/重启 up、停止 down、查看日志 logs ❖ taskctl panel \u0026lt;cmd\u0026gt; ✧ 控制面板和网页终端功能控制，开启/重启 on、关闭 off、登录信息 info、重置密码 respwd ❖ taskctl jbot \u0026lt;cmd\u0026gt; ✧ Telegram Bot 功能控制，启动/重启 start、停止 stop、查看日志 logs ❖ taskctl env \u0026lt;cmd\u0026gt; ✧ 执行环境软件包相关命令(支持 TypeSciprt 和 Python )，安装 install、修复 repairs ❖ taskctl check files ✧ 检测项目相关配置文件是否存在，如果缺失就从模板导入 ❖ update | update all ✧ 全部更新，包括项目源码、所有仓库和脚本、自定义脚本等 ❖ update \u0026lt;cmd\u0026gt; ✧ 单独更新，项目源码 shell、\u0026#34;Scripts\u0026#34;仓库 scripts、\u0026#34;Own\u0026#34;仓库 own、自定义脚本 extra ❋ \u0026lt;name\u0026gt; 脚本名(仅限scripts目录); \u0026lt;path\u0026gt; 脚本的相对路径或绝对路径; \u0026lt;cmd\u0026gt; 固定的可选命令参数; \u0026lt;url\u0026gt; 链接地址 脚本名无需输入后缀格式，前缀如果是 \u0026#34;jd_\u0026#34; 也可以省略，如果脚本同名则优先执行的是 \u0026#34;js\u0026#34; 脚本 项目仅预装 \u0026#34;JavaScript\u0026#34; 环境，支持运行 \u0026#34;js、py、ts\u0026#34; 脚本，如需运行其它类型的脚本需自行安装 📕《使用教程》  修订日期：2021 年 10 月 6 日 ㅤ  一、基础教程 1. 执行特定脚本： task \u0026lt;name/path\u0026gt; now  注：1. name 为脚本名（仅限 scripts 目录）、path 为脚本的相对路径或绝对路径。 ㅤㅤ2. 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出日志，同时记录在日志文件中。 ㅤㅤ3. 可通过下面教程中的 task list 命令具体查看本地有哪些可以执行的活动脚本。\n 2. 更新全部脚本： update 或 update all  注：每次使用前请执行此命令，确保使用最新的项目脚本和活动脚本，此脚本也配置了定时任务可自动执行。\n更新仓库时的常见报错： 提示 Repository more than 5 connections 是由于 Gitee 限制了每秒同时拉取项目的IP不能超过 5 个所导致，此报错为正常现象，重新执行更新命令即可。 提示 ssh: connect to host gitee.com port 22/443: Connection timed out 是由于您使用平台的 22/443 端口不可用所导致。 提示 Could not resolve hostname gitee.com: Temporary failure in name resolution lost connection 是由于无法解析到 Gitee 服务器，表明网络环境异常。\n 3. 查看本地脚本清单： task list 4. 查看命令帮助： task  注：所有的使用命令都在其中，并且针对不同架构的设备做了特殊处理。\n ㅤ\n二、高阶教程 1. 并发执行： task \u0026lt;name/path\u0026gt; conc  注：并发执行非常消耗资源，不要盲目使用尤其是0点，否则资源占满导致终端连不上后只能强制关机重启。\n 2. 延迟执行 task \u0026lt;name/path\u0026gt;  注：如果设置了随机延迟并且当时时间不在0-2、30-31、59分内，将随机延迟一定秒数。\n 3. 指定执行： task \u0026lt;name/path\u0026gt; \u0026lt;num\u0026gt;  注：指定某账号单独运行脚本，num为某 Cookie 账号在配置文件中的具体编号。\n 4. 远程执行： task \u0026lt;url\u0026gt; raw  注：拉取位于远程仓库的脚本后并执行，url为链接地址，可选参数(加在末尾)：-p 使用代理(Ghproxy)、-c 并发。\n 5. 迅速执行： task \u0026lt;name\u0026gt; rapid  注：此功能不会组合互助码变量，最大化降低脚本执行前耗时，主要适用于抢兑类脚本，可选参数(加在末尾)：-c 并发。\n 6. 终止执行： task \u0026lt;name/path\u0026gt; pkill  注：根据脚本名称搜索对应的进程并立即杀死，当脚本报错死循环时可使用此功能。\n 7. 全部执行： source runall 或 . runall  注：通过交互选择运行模式执行指定范围的脚本，时间较长不要盲目使用。\n 8. 单独更新部分仓库或脚本： update \u0026lt;cmd\u0026gt;  注：项目源码 shell、\u0026rdquo;Scripts\u0026rdquo;仓库 scripts、\u0026rdquo;Own\u0026rdquo;仓库 own、自定义脚本 extra。\n 9. 删除脚本运行日志： task rmlog  注：删除活动脚本与更新脚本的日志文件，默认删除 7天 以上的日志文件，可以通过配置文件中的相关变量更改默认时间值。\n 10. 进程监控： task ps  注：查看资源消耗情况和正在运行的脚本进程。\n 11. 账号功能： task cookie \u0026lt;cmd\u0026gt;  注：1. 检测账号是否有效 check，更新日期从配置文件中的备注获取，同时判断账号过期时间。 ㅤㅤ2. 使用 WSKEY 更新CK update，需要在 account.json 中正确配置您的信息，注意格式。 ㅤㅤ3. 支持指定账号进行更新，后面跟上某 Cookie 账号在配置文件中的具体编号即可，与指定执行类似。\n 12. 管理全局环境变量功能： task cookie \u0026lt;cmd\u0026gt;  注：通过交互管理全局环境变量，添加 add、删除 del、修改 edit、查询 search，支持快捷命令。\n  增加环境变量快捷命令：\ntask env add \u0026lt;变量名称\u0026gt; \u0026lt;变量的值\u0026gt; 修改环境变量快捷命令：\ntask env edit \u0026lt;变量名称\u0026gt; \u0026lt;变量新的值\u0026gt; 删除环境变量快捷命令：\ntask env del \u0026lt;变量名称\u0026gt; 启用环境变量快捷命令：\ntask env enable \u0026lt;变量名称\u0026gt; 禁用环境变量快捷命令：\ntask env disable \u0026lt;变量名称\u0026gt; 查询环境变量快捷命令：\ntask env search \u0026lt;查询关键词\u0026gt;  13. 安装环境： taskctl env install  注：全局安装常用模块便于执行非 Scripts 目录下的脚本，64位处理器还支持附带安装 Python 和 TypeSciprt 环境。\n 14. 安装脚本依赖： ## 全局安装指定模块 npm install -g \u0026lt;xxx\u0026gt;  注：1. 当脚本报错提示 need module xxx 类似字样说明缺少脚本运行所需的依赖，看见 module 字样应立即联想到安装模块上。 ㅤㅤ2. 特别要注意的是如果缺少的依赖中带有 / 则表示本地依赖文件，一般开发者都会提供相关组件，注意与安装模块区分开不要弄混。\n ㅤ\n三、互助功能教程 1. 获取互助码： task get_share_code now 2. 格式化导出互助码： task exsc  注：输出可直接应用在配置文件中的代码，其原理是从各个活动脚本的日志中获取，所以当新装环境运行完相关活动脚本后才能正常使用。\n 3. 自动互助功能： ## 在配置文件中赋值该变量 AutoHelpOther=\u0026#34;true\u0026#34;  注：详见配置文件中的相关注释，最好理解该功能的工作原理。\n 4. 手动定义互助码与相互助力： 填法示例： ## 1.定义东东农场互助 MyFruit1=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyFruit2=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyFruitA=\u0026#34;\u0026#34; MyFruitB=\u0026#34;\u0026#34; ForOtherFruit1=\u0026#34;${MyFruit1}@${MyFruit2}\u0026#34; ForOtherFruit2=\u0026#34;${MyFruit1}@${MyFruit2}\u0026#34; ## 2.定义东东萌宠互助 MyPet1=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPet2=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPet3=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPet4=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPet5=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPet6=\u0026#34;xxxxxxxxxxxxxxxxxxxxxxxxx\u0026#34; MyPetA=\u0026#34;\u0026#34; MyPetB=\u0026#34;\u0026#34; ForOtherPet1=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34; ForOtherPet2=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34; ForOtherPet3=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34; ForOtherPet4=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34; ForOtherPet5=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34; ForOtherPet6=\u0026#34;${MyPet1}@${MyPet2}@${MyPet3}@${MyPet4}@${MyPet5}@${MyPet6}\u0026#34;  注：所有符号需严格使用英文格式！如果在上一步启用了自动互助功能那么手动定义的互助码变量均会被覆盖，等于无效。\n 5. 提交您的互助码到公共助力池（Telegram Bot）：  Telegram Bot： @JD_ShareCode_Bot 每周六晚 9 点清空助力池，同时开放提交，需要加官方群才可以提交\n输入 /help 查看使用帮助\n ㅤ\n四、项目服务类功能控制教程 1. 查看所有服务的状态 taskctl server status  注：如遇相关服务没有启动或状态异常，在容器初始成功的前提下请先尝试手动启动。\n 2. 后台挂机程序  作用：在后台循环执行挂机类活动脚本。\n  启动/重启后台挂机程序：\ntaskctl hang up   注：当有新的账号添加或账号变动时须重启此程序，否则仍加载之前配置文件中的变量执行挂机活动脚本。\n  停止后台挂机程序：\ntaskctl hang down 查看后台挂机程序的运行日志：\ntaskctl hang logs   注：Ctrl+C 退出，如发现脚本报错可尝试重启。\n 3. 控制面板和网页终端  开启/重启控制面板和网页终端服务：\ntaskctl panel on   注：1. 容器第一次启动时如果启用了该功能变量后会自动启动相关服务无需手动执行此命令。 ㅤㅤ2. 在某些环境下当系统重启导致控制面板没有在容器启动时自启可用此命令手动启动。 ㅤㅤ3. 当控制面板或网页终端服务进程异常时还可尝试修复，如果仍然无法访问请检查容器是否初始化成功。\n  关闭控制面板和网页终端服务：\ntaskctl panel off 查看控制面板的登录信息：\ntaskctl panel info   注：如果忘记了登录密码可以用此方法查看。\n  重置控制面板用于登录的用户名和密码：\ntaskctl respwd   注：重置后的用户名和密码均为初始信息。\n 4. Telegram Bot  关于如何配置该功能 点此查看\n  启动/重启 Bot 服务：\ntaskctl jbot start 停止 Bot 服务：\ntaskctl jbot stop 查看 Bot 的运行日志：\ntaskctl jbot logs  ㅤ\n五、环境相关教程 1. 更新配置文件：  备份当前配置文件\ncp -f /jd/config/config.sh /jd/config/bak/config.sh 替换新版配置文件\ncp -f /jd/sample/config.sample.sh /jd/config/config.sh   注：此操作为直接替换配置文件，您也可以通过控制面板的对比工具自行修改。\n 2. 修复环境： taskctl env repairs  注：当 npm 程序崩溃时可执行此命令进行修复。\n 3. 检测配置文件完整性： taskctl check files  注：检测项目相关配置文件是否存在，如果缺失就从模板导入。\n","permalink":"https://byteprince.com/posts/d1833af6/","summary":"","title":"JDCheatsheet"},{"content":" 起因 昨晚心血来潮，看到某位博主的博客甚是眼馋——里面的相册和豆瓣内容展示页面。但是，不知道咋回事，打完几把吃鸡后头脑不在状态，折腾到很晚都没搞定。安睡一晚上，早上起床醒来，一下就搞定了。\n经过 弃用普通的HTML标记\u0026lt;center\u0026gt;图片标题\u0026lt;/center\u0026gt;作为图片标题，改用原先一直没发现的figure（其实在Hugo文档中写的很详细了，之前没有仔细的阅读），在此基础上优化了ficaption的样式。\n在themes\\PaperMod\\assets\\css\\common\\post-single.css中，添加了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  figure { text-align: center; margin: 0; } figure figcaption { text-align: center; margin:0.5rem auto 1rem; width: 40%; border-top: 1px solid #bbb; font-size:0.8em; color:#bbb; padding:5px; line-height:1.8em; } figure figcaption:before { content: \u0026#34;◎ \u0026#34;; } figure img { max-width: 100%; border-radius: 0; } @media (max-width:683px) { figure figcaption { width: 75%; } }   总结 原生的figure语法如下：\n1  {{ \u0026lt; figure align=center src=\u0026#34;image.jpg\u0026#34; \u0026gt; }}   也有人魔改了shortcode配置，使用以下的语法：\n{{ \u0026lt; figure \u0026#34;https://lmm.elizen.me/images/2021/08/obsidian-start-1.jpeg\u0026#34; \u0026#34;起始页 By Dataview\u0026#34; \u0026gt; }} 后者比前者要简洁一些，但是还是存在缺点：在 Markdown 文档中书写的时候不能直接预览图片。\n所以我还是采用 Markdown 的![]()语法来添加图片，使用\u0026lt;figure\u0026gt;\u0026lt;center\u0026gt;\u0026lt;figcaption\u0026gt;图片标题\u0026lt;/figcaption\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;figure\u0026gt;来为图片添加标题，以同时获得较好的预览体验和标题显示效果。\n","permalink":"https://byteprince.com/posts/8903c78b/","summary":"弃用普通的HTML标记作为图片标题","title":"博客图片标题的一些优化"},{"content":"Lumix GX85 + 12-60mm\nLumix GX85 + 12-60mm\n","permalink":"https://byteprince.com/posts/8c300a8c/","summary":"🌕","title":"辛丑年中秋之月"},{"content":"昨天拿到了淘来的12-60mm镜头，顺便来个全家福，纪念一下。\n图片是iPhone SE Gen2 拍的，光圈不够，后期来凑。\nPanasonic Lumix GX85 + 12-60mm F3.5-3.6 Panasonic 25mm F1.7","permalink":"https://byteprince.com/posts/86b5abd4/","summary":"","title":"穷玩摄影之装备证件照"},{"content":"在2021年4月之前，我使用 Hexo 静态博客，也曾经因为 Hexo 默认的 Markdown 渲染引擎不能很好地渲染checkbox而头疼。现在，切换到 Hugo 以后，有一次遇到了数学公式渲染的问题。\n关于 Hugo 默认的 Markdown 渲染引擎goldmark，在官方文档1中可以看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66  markup: asciidocExt: attributes: {} backend: html5 extensions: [] failureLevel: fatal noHeaderOrFooter: true preserveTOC: false safeMode: unsafe sectionNumbers: false trace: false verbose: false workingFolderCurrent: false blackFriday: angledQuotes: false extensions: null extensionsMask: null footnoteAnchorPrefix: \u0026#34;\u0026#34; footnoteReturnLinkContents: \u0026#34;\u0026#34; fractions: true hrefTargetBlank: false latexDashes: true nofollowLinks: false noreferrerLinks: false plainIDAnchors: true skipHTML: false smartDashes: true smartypants: true smartypantsQuotesNBSP: false taskLists: true defaultMarkdownHandler: goldmark goldmark: extensions: definitionList: true footnote: true linkify: true strikethrough: true table: true taskList: true typographer: true parser: attribute: block: false title: true autoHeadingID: true autoHeadingIDType: github renderer: hardWraps: false unsafe: false xhtml: false highlight: anchorLineNos: false codeFences: true guessSyntax: false hl_Lines: \u0026#34;\u0026#34; lineAnchors: \u0026#34;\u0026#34; lineNoStart: 1 lineNos: false lineNumbersInTable: true noClasses: true style: monokai tabWidth: 4 tableOfContents: endLevel: 3 ordered: false startLevel: 2   后来因为goldmark对 HTML 渲染的效果不是很满意，故修改为blackfriday。关于blackfriday，可以参考一份写的比较完善，可读性又比较强的Hugo中文文档2\n至于引入对MathJax的支持（MathJax兼容Latex），需要在 HTML 模板文件中引入相应的 JS 代码：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;script type=\u0026#34;text/x-mathjax-config\u0026#34;\u0026gt; MathJax.Hub.Config({ tex2jax: { inlineMath: [[\u0026#39;$\u0026#39;,\u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;,\u0026#39;\\\\)\u0026#39;]], processEscapes: true } }); \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#39;https://cdn.jsdelivr.net/npm/mathjax@2.7.4/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#39; async\u0026gt;\u0026lt;/script\u0026gt;   一些好用的数学工具：\n 识别并转换数学公式的网站 LaTeX Tutorial   https://gohugo.io/getting-started/configuration-markup#readout ↩︎ https://hugocn.netlify.app/configuration.html#blackfriday ↩︎  ","permalink":"https://byteprince.com/posts/2d4e6e67/","summary":"","title":"在Hugo中优雅地使用数学公式"},{"content":"引用脚注 方法1：Markdown专用写法 1 2 3 4 5  使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Typora[^T] 编辑器进行书写。 [^1]:Markdown是一种纯文本标记语言 [^2]:HyperText Markup Language 超文本标记语言 [^T]:NEW WAY TO READ \u0026amp; WRITE MARKDOWN.   方法2：设置锚点 1 2 3 4 5 6 7 8 9 10 11 12 13  ## Markdown 增加文献引用  这边文章是介绍如何在 Markdown 中增加文献引用。[\u0026lt;sup\u0026gt;1\u0026lt;/sup\u0026gt;](#refer-anchor-1) ## 参考  \u0026lt;div id=\u0026#34;refer-anchor-1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; - [1] [百度学术](http://xueshu.baidu.com/) \u0026lt;div id=\u0026#34;refer-anchor-2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; - [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page)   脚注1\n数学公式 $$ x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a} $$\n行内公式：$ \\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n} $\n行内公式示例：$x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a}$\n关于 Markdown 渲染引擎和 MathJax 支持，参考《在Hugo中优雅地使用数学公式》\n名词解释 1 2 3 4 5  Cat : Fluffy animal everyone likes Internet : Vector of transmission for pictures of cats    Cat Fluffy animal everyone likes Internet Vector of transmission for pictures of cats  各种字体 华文行楷\n华文行楷居中 我是黑体字 我是宋体字 我是微软雅黑字 我是fantasy字 我是Helvetica字 我是华文彩云\n我是红色字体，color=red \n我是黄色字体，color=yellow \n我是蓝色字体，color=blue \n我是绿色字体，color=green \n我是灰色字体，color=gray \n我是橙色字体，color=orange \n我是棕色字体，color=brown \n字体颜色，color=#FF8C69 \n字体颜色，color=#EE82EE \n字体颜色，color=#C1FFC1 \n字体颜色，color=#9B30FF \n字体颜色，color=#CD00CD \n字体颜色，color=#00B2EE \n背景色由十六进制颜色值设置而成：#FF69B4  背景色由十六进制颜色值设置而成：#FF83FA  背景色由十六进制颜色值设置而成：#40E0D0  背景色由十六进制颜色值设置而成：#C0FF3E  背景色由十六进制颜色值设置而成：#54FF9F  参考文献  https://github.com/kangzhiheng/markdown-syntax-guide https://xuchengpeng.com/hugo-blog/2018/05/25/mathjax-in-markdown-blog/   这里是脚注 ↩︎  ","permalink":"https://byteprince.com/posts/626e9457/","summary":"","title":"MyMarkdownCheatsheet"},{"content":"2017年，高考结束后没几天，拥有了第一台属于自己的手机：华为P10。\n其实这台手机我在2017年的4月份就开始关注了，第一次看到这台手机是在《电脑报》（我在高中最常看的杂志之一）的某一期上，当时一个绿色和一个钻雕蓝着实吸引了我，为我在高考后购买手机埋下了种子。在高考后，经过一番考虑，还是决定买下这台手机，4+64GB的配置，在当时拿到手也花了3600元左右。\n拿到手机的那个暑假，P10的镜头和相机给了我很多惊喜。\n拍摄于2017年6月16日 由于时间久远，这张照片👆的原图好像已经找不到了。现在看来或许宽容度实在不算出色，但是当时看到这个直出的原图后，还是感觉非常惊艳！\n拍摄于2017年6月14日 散伙饭 P10相机的德味色彩在同期的安卓机型当中还是很能打的！\n后来，上了大学后，课余时间开始接触“科技美学”之类的数码自媒体，也开始渐渐关注手机的发展，每次一有新机发布都会第一时间去看相关的测评报告，也是在这一次次的观看中，逐渐了解手机核心的几个部件：CPU，屏幕，摄像头，扬声器，充电器（后来还多了无线充电方式），另外还有耳机孔规格，防水性能，手机中框后盖材质，解锁方式，前置/后置镜头设计方案等等等等。\n在我还在上大一和大二的时候，最关注的莫过于这些所谓的配置了（其实也可以说是最为关注参数了），甚至也有过一段时间追求“跑分”的时光。\n后来我买了一部新手机：荣耀magic2。当初是冲着全面屏以及高屏占比去的，后来在一段时间的使用后，除了44W的快充以及屏占比以外，综合体验可以说是非常一般了，包括但不限于：摄像头拉跨，素质低且对焦速度慢（扫共享单车的时候尤其明显），手机发热比较严重，为了隐藏前置镜头，屏幕滑盖的设计使得散热非常糟糕……\n当手机不再是我的娱乐工具（并非说不用来娱乐）时，我才意识到，手机仅仅是一个现代化的智能通讯工具，最贴身的体验，才是每个人衡量一部手机之于自己价值的标准——而不是说，屏幕越大，参数越好看，就是好手机。\n再后来，我在2020年6月，购入了人生中第一部iPhone，也是我现在使用的主力手机，小巧的机身，玻璃后盖和金属边框带来的精致的质感，LCD屏幕（尽管是720P），指哪打哪的对焦速度和home键的解锁速度，以及iOS系统对屏幕色彩管理以及内存管理的优异，在“五福一安”的反向加持下，也可以说是瑕不掩瑜。\n现在，我的生活中，偶尔会打打“吃鸡”手游，经常会掏出手机，用相机记录身边的美好瞬间，另外，如果有优秀的屏幕，优秀的手感，流畅稳定的通讯功能，合适的电池容量，那便是我心目中最适合我的机子了。这也是我选择iPhone SE 2020的最重要的理由（电池容量除外😶）。\n后来我知道安兔兔被称为“雷兔兔”后，也就不再那么纠结跑分相差250，实际性能到底会相差多少。当然，Benchmark以及DXOMARK在我心中也是同样的遭遇，现在也仅仅将其作为参考依据之一罢了。\niPhone SE 2020的最强单摄现在我已经觉得不够用了，不说了，iPhone 13发布会听说马上要开了……\n","permalink":"https://byteprince.com/posts/6143aa48/","summary":"我们到底在追求什么体验？","title":"关于手机"},{"content":" ⼀、必备信息  对行业的了解。行业的主要玩家、发展前景、行业里每个龙头公司的产品和受众人群、行业特点。自己要面的公司有哪些产品、优劣势、竞争对手及彼此产品的优劣势。 对公司、职位需求的了解。主营业务、行业地位、职位在哪个部门要干嘛，老板是谁，日常工作需要接触哪些人和事、公司的战略发展方向。招聘就是自己要满足需求。 经历梳理。通过过去的经历来证明自己是一个值得被雇佣的人。一般是要求对简历的每个字都非常熟悉。当时发生的背景目的，如何发生，自己的角色和事情，结果是什么，学到了什么。成功和失败各准备一份。 求职动机梳理。要充分了解之后才有动机，逻辑是行业-公司-职位。动机要具体符合逻辑，为什么要进入这个公司/行业，回答要具体（如之前接触过现在的行业，以前也有一些相关性，但不要去比较，突出为什么选择现在，不要被带跑，也许 HR 只是常规问题，要专注于自己准备的内容）。 职业发展规划。长期：更希望自己10年后会成为一个怎样的人，感性一些的回答。至于3-5年的规划，可以去领英看别人的发展轨迹，要合理可行。 HR 必问题。Star原则，每个问题准备答案，扫一遍，归纳总结。准备故事打在电脑上，一半是摄像头一半是自己的笔记，但不要被对方发现自己在做准备。   Tips：如果是大公司，面试会来的人都被提前通知，要提前去Linkdin搜索，对人的了解也很重要。小公司，找机会去打听这个人。\n 二、获取信息的渠道 怎样准备行业和公司的知识： 重要性：字里行间透露你对职位了解的深浅， HR 希望对方笃定要来这个行业和知识，讲的答案更具体，给出更多的细节。 方向：\n 新闻：多看行业、公司的新闻。 资源：36氪（早晨：8点一氪），第一财经周刊，公众号的：全球企业动态，行业报告，公司官网学习话术，亲自产品试用提出建议； 内部！认识到这个公司、团队的成员，看老板的风格投其所好。 访问用户：从公众号做一个简单的分析，比如看用户反馈和后台反应速度，做一个PPT 有一些 Insight。 在知乎上看针对该行业和公司还有产品的分享。   Tips：模拟面试。别人给的反馈，这个问题的回答是否清晰，要怎样答说的更明白，多了解细分行业的公司。另外要自己录音，看表达的缺陷还有提高的地方。\n 三、如何讲故事 证明自己除了技能以外的能力，客观的表述让人感同身受。\n 选好素材。为了表现自己是一个怎样的人和特质。先要了解公司的文化，能不能很好的符合。可以准备好2-3个，1-2成功，1个失败。 描述困难。工作里遇到的困难、做了什么、怎么解决的、成与败、收获和总结。最重要的是你做了什么有影响的事，这个事情要有清晰的逻辑。所有的都要总分结构，当时主要做了\u0026hellip;前期先\u0026hellip;结合了\u0026hellip;制定了\u0026hellip;计划，涉及哪些方面。把之前的经历分解开，要放大困难（做对比去描述困难）。同时要习惯去说出数据表达，才能表示你对数据的敏感性，之后你进行了什么沟通、梳理，最后通过哪些方式的计算，保住了多少利益。 涉及到行为的问题，一般是业务部门在问，要突出你想表达的特征。 可以加料。用一些得到的积极反馈，如改变了一个怎样的机制，有目的的输出。选材不要选自己职责范围之内做的，会比较无聊，超出职责范围时间段，但是不能不做，如何用创新的方法出其不意的解决。 故事讲完，一定要反复练习讲给别人听，才知道自己讲的多烂多无聊多啰嗦。  四、表达方式  避免内容冗杂，观点不清晰。讲的每一句话都要有一个核心观点，有舍有得，突出重点。 总分结构。汇报要从大到小的原则，不要一上来就讲细节。要交代清楚背景，比如最有成就感的事：我想分享的是发生在。时候，事情-困难-解决-效果，用数据去回答效果。  五、 细节优化  自我介绍。简单清楚的总结和归类，名字-过往教育背景-职业经历-表示为这个岗位一直在做哪些努力，有一个印象。 行为性问题，给你一个场景如何解决。不要急着解答，要先回问背景和细化条件，可以要求思考时间，然后一定逻辑清晰列点说清楚。 压力面。心态要平和，不要跟着被急，要有平等的心态。面对质疑不要轻易怀疑自己的答案。问题不清楚时，一定要反问。重复问题，你想问的是？通过延时去思考。绕开不熟悉的，去回答熟悉的，尽量想一些擦边的内容，然后说我不清楚，我可以谈谈我了解的\u0026hellip; 套概念。如果别人给的问题不够清楚，要先套一个概念，比如我最大的问题是如何让自己快速成长。 专业问题回答。原则：一定要思路大于表达大于内容，思考的逻辑和因果关系是最重要的，不建议是当场组织答案，可以先看相关的书籍有一个框架和思考逻 辑，推荐《产品经理的那些事》。 思维模版。考虑目的和考核指标！预算有多少，受众有多少，如何执行，怎样追踪 KPI，这一套项目是否能被复制使用形成模版和框架用于其他的项目上。不 要觉得自己幼稚，每个人的认知都是片面的，不要束缚自己的思维，做了很多年的人也只是懂自己的部分，这个社会比自己想象的幼稚很多。 有什么想问 HR 的。不要去问不会改变的。薪资，可以问猎头。可以问 HR 如果以我的背景，在这个行业发展，有没有好的建议。或者，先说自己了解这个公司宏观的战略，是否还是这个方向，有没有新的方向。微观的是，上手后有没有人带我，因为我需要快速学习上手。 提离职。真诚和直白是最重要的。 婚姻现状，可以说家庭的观念，比较追求质量的生活，会有更多的热情去投入工作。女生的行为要为自己贏得一些尊重。 优缺点。性格比较急，如果项目进展不顺利，我会不开心，然后说如何改善。优点，揣测这个岗位的需求去说。但优缺点都要加自己的经历。 无法胜任的点。专业能力需要时间去培养。 加入能为部门带来什么？可以幽默自信的回答，可以提高颜值，考虑你比较现在团队人员的优势。   Tips：\n 面试就是量到质的飞跃过程，狂面试。本质就是要多练，练的越多，越有信心。 看看技术公司的官网简介，判断核心有价值的岗位。视频面试保证网络不要断，微笑应对。 不海投，倾尽所有去砸这个职位，瞄准目标，想明白自己的发展方向。 面试尽量要如实回答，有时候越真实越动人。 对目标公司的业务和知识是赢得信任最重要的问题，在短期内把产品知识啃下来，也是说明自己非常有学习能力。   ","permalink":"https://byteprince.com/posts/3d9fc8bc/","summary":"前期的所有准备都是为了消除信息不对等","title":"[转载] 面试的原则"},{"content":" 元素 包含开始标签（Opening tag），结束标签（Closing tag），内容（Content）三个部分\n例如：\n1  \u0026lt;p\u0026gt;我的猫非常脾气暴躁\u0026lt;/p\u0026gt;   嵌套元素 1  \u0026lt;p\u0026gt;我的猫咪脾气\u0026lt;strong\u0026gt;暴躁\u0026lt;/strong\u0026gt;:)\u0026lt;/p\u0026gt;   空元素 当然，元素可能不包含任何内容，例如元素：\n1  \u0026lt;img src=\u0026#34;images/firefox-icon.png\u0026#34; alt=\u0026#34;测试图片\u0026#34;\u0026gt;   图像 1  \u0026lt;img src=\u0026#34;images/firefox-icon.png\u0026#34; alt=\u0026#34;测试图片\u0026#34;\u0026gt;   图像地址属性：src，可在所在位置嵌入图像； 替换文字属性： alt，是图像的描述内容，用于当图像不能被用户看见时显示。\n标记文本 标题 1 2 3 4  \u0026lt;h1\u0026gt; \u0026lt;h2\u0026gt; ... \u0026lt;h6\u0026gt;   段落 1  \u0026lt;p\u0026gt;   列表  列表（Unordered List）：用一个 \u0026lt;ul\u0026gt; 元素包围。 有序列表（Ordered List）：用一个 \u0026lt;ol\u0026gt; 元素包围。  列表的每个项目用一个列表项目（List Item）元素 \u0026lt;li\u0026gt; 包围。\n链接 \u0026lt;a\u0026gt; — a 是 \u0026ldquo;anchor\u0026rdquo; （锚）的缩写。\n1  \u0026lt;a href=\u0026#34;https://www.mozilla.org/zh-CN/about/manifesto/\u0026#34;\u0026gt;Mozilla 宣言\u0026lt;/a\u0026gt;    href 代表超文本引用（ hypertext reference）。\n ","permalink":"https://byteprince.com/posts/6f917c14/","summary":"重学前端","title":"HTML 基础知识归纳"},{"content":"福建福州  来源：https://www.bilibili.com/video/BV1Wh411B7ed\n 三坊七巷 金山寺 洪塘大桥  ","permalink":"https://byteprince.com/posts/9a73dbaa/","summary":"","title":"福州"},{"content":"签字画押后，最近的一些事情也算是尘埃落定了。\n最近两年必定是值得好好回忆的两年：\n2019年底-2020年初，疫情爆发，突如其来的假期延长，直到2020年5月6日才返回学校。从寒假线上网课到后半学期的线下课程，老师和我们共同努力，完成了那个艰难的学期。\n2020年底-2021年初，面临毕业 。先是在D公司进行了一段时间的实习，结识了“大师兄”苏。实习期间有过一次杭州月会和一次温州培训，蛮累的但是也有所收获。在那段时间真的特别特别累，海投了一堆公司。\n2021年3月18日凌晨5点45分的宁波大学站\n在余姚实验学校党建活动室门口等待H老师 2021年3月18日，五点多起床去余姚参加一场信息技术教师的面试，早上先是个人信息登记与心理测评，然后是三位老师对我的首场面试：一位老师负责的是机房的管理，所以先是丢给我一根双绞线，两粒水晶头和一把压线钳，还好我记得直通线里八根线的顺序，轻松搞定了第一题计算机网络题目。第二个题目是让写两条常用的计算机网络命令，一条是ipconfig另一条是netstat。因为是面试过程中递给我一张 A4 纸，所以比较紧张把其中一个-a写成了/all。随后就是临时要求上课试讲。在一个半小时内准备好上课的内容，讲解的是“网上获取文件” 。课程内容难度并不大，可是因为课程内容是临时告知的，事先并未提前做任何准备，现场搭建 FTP 服务器和 Web 服务器以外还要制作上课用的 PPT。好在之前自己有个小网盘用于日常文件的同步，另外再来一个FTP服务器就可以了（感谢期间@SJ2050的远程协助，大带宽的美国机器抗住了50多个小朋友的并发，我的小网盘由于挂在 1M 带宽的小机器上，让小朋友们操作的时候直接503了，汗。） 中午吃完午饭后是一场笔试，笔试内容涵盖极其广泛：计算机网络，VB编程和数据结构与算法和近期一些科技名词例如NFC等名词解释都有涉及。好在数据结构的二叉树和队列，栈的知识还算熟练，呵呵。\n最后是回到党建活动室等待，没过多久应该是批阅完我的卷子了，H老师带我去见校长，期间简单地交流了一下对教育的看法和未来发展的意向。校长明确了薪水可以给到到手 *8W 一年。让我回去考虑，考虑好给回复。后来犹豫了几天，也跟父母商量了一下，自己下定决心还是拒绝掉了这个 offer。\n之后就又是漫长的海投\u0026hellip;\u0026hellip;\n直到五天前，在一个台风天，我签字画押，完成了我人生中重要的一步。\n期间还有很多值得记录的事情，挖个坑，等待后续补充\n《NY银行2021年春季校招笔试纪实》\n《NB银行2021年春季校招笔试纪实》\n《ZS银行2021年春季校招笔试纪实》\n","permalink":"https://byteprince.com/posts/6c498ezu/","summary":"","title":"记录一次十字路口的选择"},{"content":" REST Representational State Transfer = REST\n Representational = 数据的表现形式（JSON,XML等） State = 当前状态或数据 Transfer = 数据传输  REST的限制 1.客户端-服务器（Client-Server）\n 关注点分离  服务端专注数据存储，提升简单性 前端专注用户界面，提升可移植性   2.无状态（Stateless）\n 所用户会话信息都保存在客户端 每次请求必须包括所有信息，不能依赖上下文信息 服务端不用保存会话信息，提升了简单性、可靠性、可见性  3.缓存（Cache）\n 所有服务端响应都要被标注为可缓存或不可缓存 减少前后端交互，提升了性能  4.统一接口（Uniform Interface）\n 接口设计尽可能统一通用，提升了简单性和可见性 接口与实现解耦，使前后端可以独立开发迭代  5.分层系统（Layered System）\n 每层只知道相邻的一层，后面隐藏的就不知道了 客户端不知道是和代理还是真实服务器通信 其他层：安全层、负载均衡、缓存层等  6.按需代码（Code-On-Demand）\n 客户端可以下载运行服务端传来的代码（比如JS） 通过减少了一些功能简化了客户端  统一接口的限制 1.资源的标识\n 资源是任何可以命名的事物，比如用户，评论等 每个资源可以通过URI被唯一地标识  2.表述（Representation）操作资源\n 客户端不能直接操作服务端资源（比如SQL） 客户端应该通过表述来操作资源（比如JSON）  3.自描述消息\n 每个消息（请求或相应）必须提供足够的信息让接收者理解 媒体类型：application/json、application/xml HTTP方法：GET、POST、DELETE 是否缓存：Cache-Control  4.超媒体作为应用状态引擎\n 超媒体：带文字的链接 应用状态：一个网页 引擎：驱动、跳转  RESTful API  基本的URI，如https://api.github.com/users 标准HTTP方法，如：GET、POST、PUT、PATCH、DELETE等 传输的数据媒体类型，如：JSON， XML等  ","permalink":"https://byteprince.com/posts/7317a8b9/","summary":"一种设计风格和开发方式","title":"学习 RESTful"},{"content":"启动命令 docker run -dit \\ -v /opt/jd/scripts:/jd/scripts \\ -v /opt/jd/config:/jd/config \\ -v /opt/jd/log:/jd/log \\ -p 5678:5678 \\ -e ENABLE_HANGUP=false \\ -e ENABLE_WEB_PANEL=true \\ --name jd \\ --network bridge \\ --hostname jd \\ --restart always \\ supermanito/helloworld 初始密码 useradmin supermanito","permalink":"https://byteprince.com/posts/096273qi/","summary":"","title":"JDScripts_Instruction"},{"content":"这部电视剧是在今年六月初开播的，我开始看这部剧应该已经是六月末了，正直毕业季，开始实习以及一直忙于搬家等各种琐事，于是看的断断续续，好在也是在七月末将全剧看完。\n记得在今年3月的时候看完了《隐秘而伟大》，去年11月看的《瞄准》，无非都是相似的历史背景，落了俗套的抗日和内战故事情节。\n没想到《叛逆者》还给我带来了一些额外的惊喜，服化道里的一些细节着实用心，西装配饰十分齐全。\n","permalink":"https://byteprince.com/posts/422957c2/","summary":"","title":"《叛逆者》的细节用心"},{"content":"遇到这种情况先检查是否是网络问题。\n第一个报错  ssh_exchange_identification: read: Connection reset by peer\n 先是更新博客的时候发现 github 仓库失联了，在 Terminal 中尝试连接我的几个服务器，也出现kex_exchange_identification: read: Connection reset的问题，之前是配置了 SSH 密钥连接服务器的。综上，判断是 SSH 公钥有问题。\n解决方案 1.重置本地公钥\n1  ssh-keygen -t rsa -C \u0026#34;zzzain46@gmail.com\u0026#34;   之后会有几次信息确认，默认的话按回车就可以顺利完成了。\n2.配置Github的密钥\n第二个报错  fatal: refusing to merge unrelated histories\n 这是在git push 和 git pull的时候会遇到的问题，原因是本地和远程分支没有取得关系。\n解决方法 在操作命令后面加--allow-unrelated-histories可以解决。例如：\n1  git merge master --allow-unrelated-histories   或者\n1  git pull origin master --allow-unrelated-histories   附 检查本地和 Github 的 SSH 连接是否正常\n1  ssh -T git@github.com   查看 push 的方式\n1  git remote -v   移除原有的 push 方式\n1  git remote rm origin   添加新的 push 方式\n1  git remote add origin git@github.com:BytePrince/BytePrince.github.io.git  ","permalink":"https://byteprince.com/posts/b61c3883/","summary":"","title":"一次 Git 的失败记录"},{"content":"启动选项 MySQL 程序启动时指定的设置项成为启动变量（startup option）。\n例如服务器允许同时连入的客户端的默认数量是151，表的默认存储引擎是InnoDB。\n在 MySQL 安装目录的 bin 目录下的各种可执行文件（包括服务器相关的程序mysqld、mysqld_safe等，客户端相关程序mysql、mysqladmin等）基本都可以指定启动选项。\n指定选项的方法 1.命令行  只对当次启动有效。\n 进程通信设置：在启动服务器程序时禁止各客户端使用TCP/IP网络进行通信\n1  mysqld --skip-networking   等价写法：(启动选项前添加--，启动选项由多个单词组成，之间添加_或者-)\n1  mysqld --skip_networking   按照该命令启动服务器程序，再使用mysql来启动客户端程序，把服务器主机名指定为127.0.0.1的话会显示连接失败。\n1 2 3 4  mysql -h127.0.0.1 -uroot -p Enter password: ERROR 2003 (HY000):Can\u0026#39;t connect to MySQL server on \u0026#39;127.0.0.1\u0026#39;   存储引擎设置：在启动服务器程序时指定默认存储引擎\n1  mysqld --default-storage-engine=MyISAM   然后在客户端程序连接到服务器程序后创建的表默认就是用启动选项中指定的类型。\n可以使用以下命令查询表的结构（包括存储引擎）：\n1  SHOW CREATE TABLE {Table_name};   查看启动选项帮助信息：\n1 2 3  mysql --help mysqld_safe --help mysqld --verbose --help   总结\n 通用格式：\n1  mysqld --option_1[=value_1] --optio_2[=value_2] ... --option_n[=value_n]   某些选项不需要指定值，例如skip-networking等。\n 启动选项前添加--，启动选项由多个单词组成，之间添加_或者-。\n 选项名、=、选项值之间不可以由空白字符。\n 选项的长形式和短形式：\n     长形式 短形式 含义     \u0026ndash;host -h 主机名   \u0026ndash;user -u 用户名   \u0026ndash;password -p 密码   \u0026ndash;port -P 端口   \u0026ndash;version -V 版本信息    短形式只需要添加一个短划线前缀\n1  mysqld -P 3306   2.配置文件  在配置文件中，不同的选项组给不同的程序使用。其中，[server]组下面的启动选项作用于所有的服务器程序，[client]组下面的作用于所有的客户端程序。\n 2.1 配置文件路径 类 UNIX 操作系统中\n   路径名 备注     /etc/my.conf    /etc/mysql/my.conf    SYSCONFDIR/my.cnf    $MYSQL_HOME/my.conf 特定于服务器的选项（仅限服务器）   defaults-extra-file 命令行指定的额外配置文件路径   ~/.my.conf 特定于用户的选项   ~/.mylogin.conf 特定于用户的登陆路径选项（仅限客户端）    2.2 配置文件的内容 [server] skip-networking default-storage-engine=MyISAM [mysqld] ..... [mysqld_safe] ..... [client] ..... [mysql] ..... [mysqladmin] ..... 2.3 程序的对应类别和能读取的组    程序名 类别 能读取的组     mysqld 启动服务器 [mysqld]、[server]   mysqld_safe 启动服务器 [mysqld]、[server]、[mysqld_safe]   mysql.server 启动服务器 [mysqld]、[server]、[mysql.server]   mysql 启动客户端 [mysql]、[client]   mysqladmin 启动客户端 [mysqladmin]、[client]   mysqldump 启动客户端 [mysqldump]、[client]    2.4 特定 MySQL 版本的专用选项组 可以定义一个[mysqld-5.7]的选项组，含义和[mysqld]一样，不过只有版本号为 5.7 的mysqld程序才能使用这个选项组中的配置。\n2.5 配置文件的优先级  MySQL 将在某些固定的路径下搜索配置文件（配置文件路径表中的顺序依次读取各个文件，越后面的文件优先级越高） MySQL 也可以通过在命令行中指定defaults-extra-file启动选项来指定额外的配置文件路径  2.6 同一个配置文件中的优先级 越靠后的优先级越高。\n2.7 defaults-file 的使用  不搜索默认路径下的配置文件\n1  mysqld --defaults-file=/tmp/myconfig.txt   搜索默认的配置文件路径\n1  mysqld --defaults-extra-file=/tmp/myconfig.txt    3.命令行和配置文件中启动选项的优先级 命令行 \u0026gt; 配置文件\n系统变量  大多数系统变量的值都可以在程序运行过程中修改，而无需停止并重启服务器。\n 查看系统变量 SHOW VARIABLES [LIKE 匹配的模式]; 如，查询以 default 开头的系统变量的值\n1  SHOW VARIABLES LIKE \u0026#39;default%\u0026#39;;   设置系统变量 通过命令行添加启动选项 1  mysqld --default-storage-engine=MyISAM --maxconnections=10   通过配置文件添加启动选项 1 2 3  [server] default-storage-engine=MyISAM max-connections=10    通常情况下，长变量之间建议使用_连接。对于⼤部分系统变量来说，它们的值可以在服务器程序运⾏过程中进⾏动态修改⽽⽆需停⽌并重启服务器。\n 系统变量的作用范围  GLOBAL：全局变量，影响服务器的整体操作。 SESSION：会话变量（可以理解为私有的系统变量），影响某个客户端连接的操作。（注：SESSION有个别名叫LOCAL）   在服务器启动时，会将每个全局变量初始化为其默认值（可以通过命令⾏或选项⽂件中指定的选项更改这些默认值）。然后服务器还为每个连接的客户端维护⼀组会话变量，客户端的会话变量在连接时使⽤相应全局变量的当前值初始化。这话有点⼉绕，还是以default_storage_engine举例，在服务器启动时会初始化⼀个名为default_storage_engine，作⽤范围为GLOBAL的系统变量。之后每当有⼀个客户端连接到该服务器时，服务器都会单独为该客户端分配⼀个名为default_storage_engine，作⽤范围为SESSION的系统变量，该作⽤范围为SESSION的系统变量值按照当前作⽤范围为GLOBAL的同名系统变量值进⾏初始化。\n 指定系统变量的作用范围 SET [GLOBAL|SESSION] 系统变量名 = 值; 或者\nSET [@@(GLOBAL|SESSION).]var_name = XXX; 例如，需要修改default_storage_engine变量的值，\n全局变量的修改：\n语句⼀：SET GLOBAL default_storage_engine = MyISAM; 语句⼆：SET @@GLOBAL.default_storage_engine = MyISAM; 会话变量的修改：\n语句⼀：SET SESSION default_storage_engine = MyISAM; 语句⼆：SET @@SESSION.default_storage_engine = MyISAM; 语句三：SET default_storage_engine = MyISAM;  SET 系统变量名 = 值 \u0026lt;=\u0026gt; SET SESSION 系统变量名 = 值\n 查看不同作用范围的系统变量 SHOW [GLOBAL|SESSION] VARIABLES [LIKE 匹配的模式]; 例如：\n1 2  SHOW SESSION VARIABLES LIKE \u0026#39;default_storage_engine\u0026#39;; SHOW GLOBAL VARIABLES LIKE \u0026#39;default_storage_engine\u0026#39;;    1.如果某个客户端改变了某个系统变量在GLOBAL作⽤范围的值，并不会影响该系统变量在当前已经连接的客户端作⽤范围SESSION的值，只会影响后续连⼊的客户端在作⽤范围为SESSION的值。\n2.并不是所有系统变量都具有GLOBAL和SESSION的作⽤范围\n有⼀些系统变量只具有GLOBAL作⽤范围，比如max_connections，表示服务器程序⽀持同时最多有多少个客户端程序进⾏连接。有⼀些系统变量只具有SESSION作⽤范围，⽐如insert_id，表示插⼊值时使⽤的AUTO_INCREMENT修饰的列的值。有⼀些系统变量的值既具有GLOBAL作⽤范围，也具有SESSION作⽤范围，⽐如我们前边⽤到的default_storage_engine，⽽且其实⼤部分的系统变量都是这样的，\n3.有些系统变量是只读的，并不能设置值，如version。\n4.系统变量和启动选项的关系\n有些系统变量是在程序运⾏过程中⾃动⽣成的，是不可以当作启动选项来设置，⽐如auto_increment_offset、character_set_client。有些启动选项也不是系统变量，⽐如defaults-file。\n 状态变量 ⽤来显示服务器程序运⾏状况。与系统变量类似，状态变量也有GLOBAL和SESSION两个作⽤范围。\n查看状态变量 SHOW [GLOBAL|SESSION] STATUS [LIKE 匹配的模式];","permalink":"https://byteprince.com/posts/e50d7dqi/","summary":"","title":"MySQL进阶：启动选项和系统变量"},{"content":" 转载自：阮一峰博客\n","permalink":"https://byteprince.com/posts/e6d1bba4/","summary":"","title":"[转载]关于各类开源协议的区别"},{"content":"查询并结束文件关联的进程 1  tasklist /m D:\\task.txt  1  taskkill /f /im 进程ID   删除文件 递归删除文件夹a1\n1  rd /s 文件夹路径   强制删除文件\n1  del /s 文件路径  ","permalink":"https://byteprince.com/posts/40fef465/","summary":"","title":"删除 Windows 下被占用的文件"},{"content":" 查看firewall服务状态 1  systemctl status firewalld   查看firewall状态 1  firewall-cmd --state   开启、关闭、重启firewalld服务 1 2 3 4 5 6  # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop   查看防火墙规则 1  firewall-cmd --list-all   查询、开放、关闭端口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  # 查询端口是否开放 firewall-cmd --query-port=8080/tcp # 开放80端口 firewall-cmd --permanent --add-port=80/tcp firewall-cmd --permanent --add-port=8080-8085/tcp # 移除端口 firewall-cmd --permanent --remove-port=8080/tcp 查看防火墙的开放的端口 firewall-cmd --permanent --list-ports #重启防火墙(修改配置后要重启防火墙) firewall-cmd --reload # 参数解释 1、firwall-cmd：是Linux提供的操作firewall的一个工具； 2、--permanent：表示设置为持久； 3、--add-port：标识添加的端口；  ","permalink":"https://byteprince.com/posts/ecd7a7b7/","summary":"firewall常用命令","title":"CentOS 7 防火墙配置"},{"content":"1.1MySQL总览  采用C/S架构，用户通过客户端程序发送增删查改请求，服务器程序收到请求后处理，并把处理结果返回给客户端。 MySQL安装目录的bin目录下存放着两类可执行文件：服务器程序（例如mysqld、mysql_safe），客户端程序（例如mysql、mysqladmin）  1.2MySQL启动 服务端的启动 以类unix系统为例\n1  mysql.server start/stop   客户端的启动 1  mysql -h主机名 -u用户名 -p密码    一般更建议采用非显式输入密码\n1  mysql -h主机名 -u用户名 -p   客户端和服务端的三种连接方式 TCP/IP MySQL词采用TCP作为服务i其和客户端之间的网络通信协议。MySQL服务器默认监听3306端口，也可以在启动MySQL服务器的时候指定端口：\n1  mysqld -P3307   命名管道和共享内存  适合在Windows使用。\n 使用共享内存进行通信的服务器进程和客户端进程必须位于同一台Windows主机中。\nUNIX域套接字  适合类服务器进程和客户端进程都运行在同一台类UNIX系统机器上。\n 1.3SQL的执行过程  连接器处理连接 查询缓存看是否命中 分析器分析语法 优化器生成执行计划（可以使用EXPLAIN语句来查看某个语句的执行计划） 执行器调用存储引擎的API执行，返回执行结果到客户端（存储引擎提供数据存储和提取API）   存储引擎\n 存储引擎是表级别的，不同存储引擎管理的表可能有不同的数据结构，采用的存取算法也不同。\n 常用的存储引擎有InnoDB（支持事务，行级锁，外键），MyISAM（主要的非事务处理存储引擎），MEMORY（数据只存在内存，不存储在磁盘，多用于临时表）等。\n 存储引擎的查看和设置语句\n  ","permalink":"https://byteprince.com/posts/cdbe8ab7/","summary":"","title":"MySQL进阶：关于MySQL"},{"content":" 1 Python开发环境安装  Python解释器  解释器的作用 解释器的种类 CPython：C语言开发的解释器，应用最为广泛。 IPython：基于CPython的一种交互式解释器。 其他解释器  PyPy：基于Python语言开发的解释器。 JPython：运行在Java平台的解释器，直接把Python代码编译成Java字节码执行。 IronPython：运行在微软dotnet平台上的Python解释器，可以直接把Python代码编译成dotnet字节码执行。   Python常用IDE：  Pycharm 修改外观  字体，字号，行距，配色（主题） 开启Ctrl+滚轮方所编辑器字体 关闭弱警告等提示（可选）  修改解释器 项目管理 VS Code   2 Python基础知识  注释 变量  命名规范： 数字字母下划线； 非数字开头； 非内置关键字； 大小写敏感。 命名习惯： 见名知义 大驼峰：MyName 小驼峰：myName 下划线：my_name  调试  断点 Debug   3 Python数据类型和常用操作 数据类型 输出 格式化符号    格式符号 转换     ==%s== 字符串   ==%d== 有符号的十进制整数   ==%f== 浮点数   %c 字符   %u 无符号十进制整数   %o 八进制整数   %x 十六进制整数（小写ox）   %X 十六进制整数（大写OX）   %e 科学计数法（小写\u0026rsquo;e\u0026rsquo;）   %E 科学计数法（大写\u0026rsquo;E\u0026rsquo;）   %g %f和%e的简写   %G %f和%E的简写     技巧\n  %06d，表示输出的整数显示位数，不足以0补全，超出当前位数则原样输出 %.2f，表示小数点后显示的小数位数。  实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  age = 18 name = \u0026#39;TOM\u0026#39; weight = 75.5 student_id = 1 # 我的名字是TOM print(\u0026#39;我的名字是%s\u0026#39; % name) # 我的学号是0001 print(\u0026#39;我的学号是%4d\u0026#39; % student_id) # 我的体重是75.50公斤 print(\u0026#39;我的体重是%.2f公斤\u0026#39; % weight) # 我的名字是TOM，今年18岁了 print(\u0026#39;我的名字是%s，今年%d岁了\u0026#39; % (name, age)) # 我的名字是TOM，明年19岁了 print(\u0026#39;我的名字是%s，明年%d岁了\u0026#39; % (name, age + 1)) # 我的名字是TOM，明年19岁了 print(f\u0026#39;我的名字是{name}, 明年{age + 1}岁了\u0026#39;)   f表达式  f-格式化字符串是Python3.6新增的格式化方法，简单易读。\n 1  f\u0026#39;{表达式}\u0026#39;   转义字符  \\n：换行。 \\t：制表符，一个Tab键（4个空格）的距离。  结束符  想一想，为什么两个 print 会换行输出？\n 1  print(\u0026#39;输出的内容\u0026#39;, end=\u0026#34;\\n\u0026#34;)    在 Python 中，print() 默认自带end=\u0026quot;\\n\u0026quot;这个换行结束符，所以导致每两个print()直接会换行展示，用户可以按需求更改结束符。\n 输入  注意\n  当程序执行到input，等待用户输入，输入完成之后才继续向下执行。 在 Python 中，input接收用户输入后，一般存储到变量，方便使用。 在 Python 中，input会把接收到的任意用户输入的数据都当做字符串处理。\n1  input(\u0026#39;请输入您的密码:\u0026#39;)    数据类型转换    函数 说明     int(x [,base ]) 将x转换为一个整数   float(x ) 将x转换为一个浮点数   complex(real [,imag ]) 创建一个复数，real为实部，imag为虚部   str(x) 将对象 x 转换为字符串   repr(x) 将对象 x 转换为表达式字符串   eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象   tuple(s) 将序列 s 转换为一个元组   list(s) 将序列 s 转换为一个列表   chr(x) 将一个整数转换为一个Unicode字符   ord(x) 将一个字符转换为它的ASCII整数值   hex(x) 将一个整数转换为一个十六进制字符串   oct(x) 将一个整数转换为一个八进制字符串   bin(x) 将一个整数转换为一个二进制字符串    实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # str() -- 转换成字符串类型 num2 = 10 print(type(str(num2))) # tuple() -- 将一个序列转换成元组 list1 = [10, 20, 30] print(tuple(list1)) print(type(tuple(list1))) # list() -- 将一个序列转换成列表 t1 = (100, 200, 300) print(list(t1)) print(type(list(t1))) # eval() -- 将字符串中的数据转换成Python表达式原本类型 str1 = \u0026#39;10\u0026#39; str2 = \u0026#39;[1, 2, 3]\u0026#39; str3 = \u0026#39;(1000, 2000, 3000)\u0026#39; print(type(eval(str1))) print(type(eval(str2))) print(type(eval(str3)))   运算符 见《Python运算符》\n4 Python基本语句 条件语句  if语句语法\n1 2  if condition_1: statement_block_1   if\u0026hellip;else\u0026hellip;\n1 2 3 4  if condition_1: statement_block_1 else: statement_block_3   多重判断\n1 2 3 4 5 6  if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3   if嵌套\n1 2 3 4  if condition_1: statement_block_1 if condition_2: statement_block_2    循环语句  循环的作用：控制代码重复执行 while语法\n1 2 3 4  while condition: statement_block_1 statement_block_2 ......   while循环嵌套语法\n1 2 3 4 5 6  while condition1: statement_block_1 ...... while condition2: statement_block_2 ......   for循环语法\n1 2 3 4  for 临时变量 in 序列: 重复执行的代码1 重复执行的代码2 ......   break退出整个循环\n continue退出本次循环，继续执行下一次重复执行的代码\n else\n while和for都可以配合else使用 else下方缩进的代码含义：当循环正常结束后执行的代码 break终止循环不会执行else下方缩进的代码 continue退出循环的方式执行else下方缩进的代码   循环实例 1 2 3 4 5 6 7 8  str1 = \u0026#39;itheima\u0026#39; for i in str1: if i == \u0026#39;e\u0026#39;: print(\u0026#39;遇到e不打印\u0026#39;) break ###退出整个for循环 print(i) else: print(\u0026#39;循环正常结束之后执行的代码\u0026#39;)  1 2 3 4 5 6 7 8  str1 = \u0026#39;itheima\u0026#39; for i in str1: if i == \u0026#39;e\u0026#39;: print(\u0026#39;遇到e不打印\u0026#39;) continue ###退出if循环 print(i) else: print(\u0026#39;循环正常结束之后执行的代码\u0026#39;)   5 Python数据序列 集合（set）  无序的不重复元素序列\n 🔔建  创建集合使用{}或set()， 但是如果要创建空集合只能使用set()，因为{}用来创建空字典。\n    方法 作用 举例     {xx,xx,xx,xx} 创建非空集合 s1 = {10, 20, 30, 40, 50}   set() 创建集合 s3 = set(\u0026lsquo;abcdefg\u0026rsquo;)\ns4 = set()   {} 创建空字典 s5 = {}print(type(s5)) # dict    🔔增  集合天然有去重功能\n s1 = {10, 20, 30, 40, 50}\n   函数 作用 举例     add() 追加一个元素 s1.add(300)   update() 追加一个序列 s1.update([100,500])    🔔删 s1 = {10, 20, 30, 40, 50}\n   函数 作用 举例     remove() 删除数据，如果被删除数据不存在则报错 s1.remove(10)   discard() 删除数据，如果数据不存在也不报错 s1.discard()   pop() 随机删除集合中的某个数据，并返回被删除数据 del_num = s1.pop()print(del_num)print(s1)    🔔其他函数 s1 = {10, 20, 30, 40, 50}\n   Python 表达式 作用 举例     in / not in 判断某个元素是否在集合中，返回真假 10 in s1   len() 取集合长度 len(s1)    列表（list）  Python 中最基本的数据结构\n 🔔建  list = []  🔔访问元素 根据下标访问  list[index]  \n其他函数  index()：返回指定数据所在位置的下标。查询的数据不存在则报错。\n1  列表序列.index(数据, 开始位置下标, 结束位置下标)  1 2 3  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] print(name_list.index(\u0026#39;Lily\u0026#39;, 0, 2))    count()：统计指定数据在当前列表中出现的次数。\n1 2 3  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] print(name_list.count(\u0026#39;Lily\u0026#39;))    🔔其他函数    Python 表达式 结果 描述     3 in (1, 2, 3) True 元素是否存在   元组序列.index(数据, 开始位置下标, 结束位置下标) 下标或报错 查找元素的位置   len((1, 2, 3)) 3 计算元素个数   max(\u0026lsquo;5\u0026rsquo;,\u0026lsquo;4\u0026rsquo;,\u0026lsquo;8\u0026rsquo;) 8 取最大值   min(\u0026lsquo;5\u0026rsquo;,\u0026lsquo;4\u0026rsquo;,\u0026lsquo;8\u0026rsquo;) 4 取最小值   (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接   (\u0026lsquo;Hi!\u0026rsquo;,) *** 4** (\u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;) 复制   for x in (1, 2, 3): print (x,) 1 2 3 迭代   tuple(iterable) tuple1=tuple(list1) 例如，将列表转换成元组    🔔增  append()：可以追加元素或序列，当追加的是序列的时候，序列作为一个新的元素被追加到原来的列表中\n1 2 3 4 5 6  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] name_list.append([\u0026#39;xiaoming\u0026#39;, \u0026#39;xiaohong\u0026#39;]) # 结果：[\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;, [\u0026#39;xiaoming\u0026#39;, \u0026#39;xiaohong\u0026#39;]] print(name_list)   extend()：列表追加数据，若数据时序列，则将序列拆分成元素逐一添加\n1 2 3 4 5 6  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] name_list.extend([\u0026#39;xiaoming\u0026#39;, \u0026#39;xiaohong\u0026#39;]) # 结果：[\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;, \u0026#39;xiaoming\u0026#39;, \u0026#39;xiaohong\u0026#39;] print(name_list)   insert()：指定位置新增数据\n1 2 3 4 5 6 7 8  列表序列.insert(位置下标, 数据) name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] name_list.insert(1, \u0026#39;xiaoming\u0026#39;) # 结果：[\u0026#39;Tom\u0026#39;, \u0026#39;xiaoming\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] print(name_list)    🔔删  del  del 列表名 删除整个列表 del 列表名[index] 删除指定元素  pop()\n list.pop(index) 删除指定下标的数据(默认为最后一个)，并返回该数据\n1 2 3 4 5 6 7 8 9  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] del_name = name_list.pop(1) # 结果：Lily print(del_name) # 结果：[\u0026#39;Tom\u0026#39;, \u0026#39;Rose\u0026#39;] print(name_list)    remove()\n list.remove('元素') 删除列表中某个数据的第一匹配项\n1 2 3 4 5 6  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] name_list.remove(\u0026#39;Rose\u0026#39;) # 结果：[\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;] print(name_list)    clear()：清空列表\n1 2 3 4  name_list = [\u0026#39;Tom\u0026#39;, \u0026#39;Lily\u0026#39;, \u0026#39;Rose\u0026#39;] name_list.clear() print(name_list) # 结果： []    元组（tuple）  元组与列表（list）类似，不同之处在于：\n①元组的元素不能修改；\n②组使用小括号 ( )，列表使用方括号 [ ].\n 🔔建 1 2 3 4 5 6 7 8  #新建一个空元组 tup1 = () #新建一个仅含一个元素的元组,逗号不能省，否则会被定义为原始的类型 tup2 = (46,) #print结果为str tup3 = (\u0026#39;hello\u0026#39;)   🔔访问元素  与列表类似。\n 1 2 3 4 5  #访问多个元素，“左闭右开” [左边界:右边界] #某个值开始后面所有元素(右边界省略) [左边界:]   🔔其他函数    Python 表达式 结果 描述     3 in (1, 2, 3) True 元素是否存在   元组序列.index(数据, 开始位置下标, 结束位置下标) 下标或报错 查找元素的位置   len((1, 2, 3)) 3 计算元素个数   max(\u0026lsquo;5\u0026rsquo;,\u0026lsquo;4\u0026rsquo;,\u0026lsquo;8\u0026rsquo;) 8 取最大值   min(\u0026lsquo;5\u0026rsquo;,\u0026lsquo;4\u0026rsquo;,\u0026lsquo;8\u0026rsquo;) 4 取最小值   (1, 2, 3) + (4, 5, 6) (1, 2, 3, 4, 5, 6) 连接   (\u0026lsquo;Hi!\u0026rsquo;,) *** 4** (\u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;, \u0026lsquo;Hi!\u0026rsquo;) 复制   for x in (1, 2, 3): print (x,) 1 2 3 迭代   tuple(iterable) tuple1=tuple(list1) 例如，将列表转换成元组    🔔拼接 1 2 3 4 5 6 7 8 9  tup1 = (12, 34.56) tup2 = (\u0026#39;abc\u0026#39;, \u0026#39;xyz\u0026#39;) # 以下修改元组元素操作是非法的。 # tup1[0] = 100 # 创建一个新的元组 tup3 = tup1 + tup2 print (tup3)   🔔删  元组内的元素不可被删除\n  del\n1 2 3 4  tup = (\u0026#39;Google\u0026#39;, \u0026#39;pwner\u0026#39;, 1997, 2000) del tup #删除后tup对象未定义    ⚠️关于元组不可变 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  tup = (\u0026#39;p\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;r\u0026#39;) tup[0] = \u0026#39;g\u0026#39; # 不支持修改元素 Traceback (most recent call last): File \u0026#34;\u0026lt;stdin\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment # 查看内存地址 id(tup) 4440687904 tup = (1,2,3) # 内存地址不一样了 id(tup) 4441088800    字典（dict） 🔔建 1 2 3 4 5 6 7  # 有数据字典 dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} # 空字典 dict2 = {} dict3 = dict()   🔔访问 访问某个键值 1 2 3 4 5 6 7  d = {key1 : value1, key2 : value2, key3 : value3 } #访问key1的值 value = d[\u0026#39;key1\u0026#39;] #访问key1的值 value2 = dict1.get(\u0026#39;key1\u0026#39;)   访问所有键名  keys()\n1 2 3 4 5  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} print(dict1.keys()) # dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;, \u0026#39;gender\u0026#39;])    访问所有键值  values()\n1 2 3 4 5  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} print(dict1.values()) # dict_values([\u0026#39;Tom\u0026#39;, 20, \u0026#39;男\u0026#39;])    访问所有键值对 1 2 3 4 5  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} print(dict1.items()) # dict_items([(\u0026#39;name\u0026#39;, \u0026#39;Tom\u0026#39;), (\u0026#39;age\u0026#39;, 20), (\u0026#39;gender\u0026#39;, \u0026#39;男\u0026#39;)])   🔔遍历 遍历键名 1 2 3  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} for key in dict1.keys(): print(key)   遍历键值 1 2 3  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} for value in dict1.values(): print(value)   遍历键值对 1 2 3  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} for item in dict1.items(): print(item)   格式化遍历键值对 1 2 3  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;Tom\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;gender\u0026#39;: \u0026#39;男\u0026#39;} for key, value in dict1.items(): print(f\u0026#39;{key}= {value}\u0026#39;)   🔔改 1  d[\u0026#39;key1\u0026#39;] = 新值   🔔删 1 2 3 4 5 6 7  dict = {\u0026#39;Name\u0026#39;: \u0026#39;Pwner\u0026#39;, \u0026#39;Age\u0026#39;: 7, \u0026#39;Class\u0026#39;: \u0026#39;First\u0026#39;} del dict[\u0026#39;Name\u0026#39;] # 删除键 \u0026#39;Name\u0026#39; dict.clear() # 清空字典 del dict # 删除字典   ⚠️注意  字典中键不能重复，若重复只保留最后一个键值对 字典可变，键不可变。（键不可为列表类型）  数据序列的公共操作 详见《Python序列公共操作》\n推导式  可以理解为数学中，给出通项公式，快速生成一个数列。\n 详见《推导式》\n6 Python函数  封装代码，高效的代码重用\n 函数使用步骤  定义函数\ndef 函数名(): 代码1 代码2 ... 调用函数\n函数名()  函数的说明文档  保存函数解释说明的信息，便于在大型项目中方便直接调取说明文档。\n  写法\ndef 函数名(): \u0026#34;\u0026#34;\u0026#34; 函数说明文档 \u0026#34;\u0026#34;\u0026#34; def sum_num(a, b): \u0026#34;\u0026#34;\u0026#34; 求和函数 \u0026#34;\u0026#34;\u0026#34; return a + b #调取sum_num()函数的说明文档 help(sum_num)  变量作用域  局部变量 全局变量（较少使用，一般传参实现变量的复用）  函数的参数  函数调用的时候可以传入真实数据，增大函数的使用的灵活性\n  形参：函数定义时书写的参数(非真实数据) 实参：函数调用时书写的参数(真实数据)\ndef sum_num(形参1, 形参2): \u0026#34;\u0026#34;\u0026#34; 求和函数 \u0026#34;\u0026#34;\u0026#34; return a + b sun_num(实参1,实参2)  位置参数  调用函数时根据函数定义的参数位置来传递参数。\n传递和定义参数的顺序及个数必须一致。\n 1 2 3 4 5  def user_info(name, age, gender): print(f\u0026#39;您的名字是{name}, 年龄是{age}, 性别是{gender}\u0026#39;) user_info(\u0026#39;TOM\u0026#39;, 20, \u0026#39;男\u0026#39;)   关键字参数  函数调用，通过“键=值”形式加以指定。可以让函数更加清晰、容易使用。\n函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序。\n 1 2 3 4 5 6  def user_info(name, age, gender): print(f\u0026#39;您的名字是{name}, 年龄是{age}, 性别是{gender}\u0026#39;) user_info(\u0026#39;Rose\u0026#39;, age=20, gender=\u0026#39;女\u0026#39;) user_info(\u0026#39;小明\u0026#39;, gender=\u0026#39;男\u0026#39;, age=16)   缺省参数  缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）。\n 1 2 3 4 5 6  def user_info(name, age, gender=\u0026#39;男\u0026#39;): print(f\u0026#39;您的名字是{name}, 年龄是{age}, 性别是{gender}\u0026#39;) user_info(\u0026#39;TOM\u0026#39;, 20) user_info(\u0026#39;Rose\u0026#39;, 18, \u0026#39;女\u0026#39;)   不定长参数  不定长参数也叫可变参数。用于不确定调用的时候会传递多少个参数(不传参也可以)的场景。此时，可用包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便。可变参数传递就是一个组包的过程。\n  包裹位置传递   收集所有位置参数，返回一个元组。\n 传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是包裹位置传递。\n1 2 3 4 5 6 7 8  def user_info(*args): print(args) # (\u0026#39;TOM\u0026#39;,) user_info(\u0026#39;TOM\u0026#39;) # (\u0026#39;TOM\u0026#39;, 18) user_info(\u0026#39;TOM\u0026#39;, 18)    包裹关键字传递   收集所有关键字参数，返回一个字典\n 1 2 3 4 5 6  def user_info(**kwargs): print(kwargs) # {\u0026#39;name\u0026#39;: \u0026#39;TOM\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;id\u0026#39;: 110} user_info(name=\u0026#39;TOM\u0026#39;, age=18, id=110)   拆包  拆包：元组\n1 2 3 4 5 6 7  def return_num(): return 100, 200 num1, num2 = return_num() print(num1) # 100 print(num2) # 200   拆包：字典\n1 2 3 4 5 6 7 8 9  dict1 = {\u0026#39;name\u0026#39;: \u0026#39;TOM\u0026#39;, \u0026#39;age\u0026#39;: 18} a, b = dict1 # 对字典进行拆包，取出来的是字典的key print(a) # name print(b) # age print(dict1[a]) # TOM print(dict1[b]) # 18    函数的返回值 1 2 3 4  def log(): print(\u0026#39;hello\u0026#39;) return 1 #退出函数 return 2 #不执行此行   多个返回值   return a, b写法，返回多个数据的时候，默认是元组类型。 return后面可以连接列表、元组或字典，以返回多个值。   1 2 3 4 5 6  def return_num(): return 1, 2 result = return_num() print(result) # (1, 2)   多函数程序执行流程  共用全局变量 返回值作为参数传递  引用  Python中，数据的传递都是通过引用来实现\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  # 1. int类型 a = 1 b = a print(b) # 1 print(id(a)) # 140708464157520 print(id(b)) # 140708464157520 a = 2 print(b) # 1,说明int类型为不可变类型  print(id(a)) # 140708464157552，此时得到是的数据2的内存地址 print(id(b)) # 140708464157520 # 2. 列表 aa = [10, 20] bb = aa print(id(aa)) # 2325297783432 print(id(bb)) # 2325297783432 aa.append(30) print(bb) # [10, 20, 30], 列表为可变类型 print(id(aa)) # 2325297783432 print(id(bb)) # 2325297783432  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def test1(a): print(a) print(id(a)) a += a print(a) print(id(a)) # int：计算前后id值不同 b = 100 test1(b) # 列表：计算前后id值相同 c = [11, 22] test1(c)   可变类型与不可变类型 所谓可变类型与不可变类型是指：数据能够直接进行修改，如果能直接修改那么就是可变，否则是不可变.\n 可变类型  列表 字典 集合  不可变类型  Number（整型，浮点型） 字符串 元组   lambda表达式  匿名函数。如果一个函数有一个返回值，并只有一句代码，那么可以使用lambda简化。\nlambda本质上还是一个函数，所以同样遵守函数的参数和返回值的规定，即可以拥有0个或者多个参数，只有一个返回值。\n 语法 1  lambda 参数:表达式   实例 1 2 3 4 5 6 7 8 9 10 11 12  #编写一个函数实现两数的相加 def add(a,b): return a+b print(add(2,3)) #使用lambda表达式来简化上述函数 fn1 = lambda a,b:a+b print(fn1) #输出fn1的内存地址 print(fn1(1,2)) #调用lambda表达式，计算2+3   lambda的不同参数形式 1.无参数 1 2  fn1 = lambda:100 print(fn1())   2.一个参数 1 2  fn1 = lambda a:a print(fn1(\u0026#39;hello world\u0026#39;))   3.默认参数 1 2  fn1 = lambda a, b, c=100:a + b + c print(fn1(10, 20))   4.可变参数：*args  不定长位置参数\n注意：这里的可变参数传入到lambda之后，返回值为元组。\n 1 2  fn1 = lambda *args:args print(fn1(10, 20, 30))   5.可变参数：**kwargs  不定长关键字参数\n 1 2  fn1 = lambda **kwargs:kwargs print(fn1(name=\u0026#39;python\u0026#39;, age=20))   lambda的应用 1.带判断的lambda 1 2  fn1 = lambda a, b: a if a \u0026gt; b else b print(fn1(1000, 500))   2.列表数据按字典key的值排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  students = [ {\u0026#39;name\u0026#39;: \u0026#39;TOM\u0026#39;, \u0026#39;age\u0026#39;: 20}, {\u0026#39;name\u0026#39;: \u0026#39;ROSE\u0026#39;, \u0026#39;age\u0026#39;: 19}, {\u0026#39;name\u0026#39;: \u0026#39;Jack\u0026#39;, \u0026#39;age\u0026#39;: 22} ] # 按name值升序排列 students.sort(key=lambda x: x[\u0026#39;name\u0026#39;]) print(students) # 按name值降序排列 students.sort(key=lambda x: x[\u0026#39;name\u0026#39;], reverse=True) print(students) # 按age值升序排列 students.sort(key=lambda x: x[\u0026#39;age\u0026#39;]) print(students)   高阶函数  把函数作为参数传入，这样的函数称为高阶函数，高阶函数是函数式编程的体现。函数式编程就是指这种高度抽象的编程范式，所以具有开发速度快的特点。\n 实例 在Python中，abs()函数可以完成对数字求绝对值计算。\n1  abs(-10) # 10   round()函数可以完成对数字的四舍五入计算。\n1 2  round(1.2) # 1 round(1.9) # 2   需求：任意两个数字，按照指定要求整理数字后再进行求和计算。\n 方法1\n1 2 3 4 5 6  def add_num(a, b): return abs(a) + abs(b) result = add_num(-1, 2) print(result) # 3   方法2\n1 2 3 4 5 6  def sum_num(a, b, f): return f(a) + f(b) result = sum_num(-1, 2, abs) print(result) # 3     注意：两种方法对比之后，发现，方法2的代码会更加简洁，函数灵活性更高。\n 内置高阶函数 🔔map() map(func, lst)，将传入的函数变量func作用到lst变量的每个元素中，并将结果组成新的列表(Python2)/迭代器(Python3)返回。\n需求：计算list1序列中各个数字的2次方。\n1 2 3 4 5 6 7 8 9 10 11  list1 = [1, 2, 3, 4, 5] def func(x): return x ** 2 result = map(func, list1) print(result) # \u0026lt;map object at 0x0000013769653198\u0026gt; print(list(result)) # [1, 4, 9, 16, 25]   🔔reduce() reduce(func，lst)，其中func必须有两个参数。每次func计算的结果继续和序列的下一个元素做累积计算。\n 注意：reduce()传入的参数func必须接收2个参数。\n 需求：计算list1序列中各个数字的累加和。\n1 2 3 4 5 6 7 8 9 10 11 12  import functools list1 = [1, 2, 3, 4, 5] def func(a, b): return a + b result = functools.reduce(func, list1) print(result) # 15   🔔filter() filter(func, lst)函数用于过滤序列, 过滤掉不符合条件的元素, 返回一个 filter 对象。如果要转换为列表, 可以使用 list() 来转换。\n1 2 3 4 5 6 7 8 9 10 11  list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] def func(x): return x % 2 == 0 result = filter(func, list1) print(result) # \u0026lt;filter object at 0x0000017AF9DC3198\u0026gt; print(list(result)) # [2, 4, 6, 8, 10]  ","permalink":"https://byteprince.com/posts/a5648380/","summary":"关于Python基础的种种","title":"Python 基础知识提纲"},{"content":" 有时候需要在多个节点配置相同的环境，可以采用Docker的方式批量部署，也可以直接手动创建对应的环境。\n no subshells, no profile setup, no convoluted.\n Nodejs可以通过n模块来实现版本管理。\n1 安装 n 模块 已经安装了node，就可以用npm安装n模块\n1  npm install -g n   2 安装 Node 安装最新版 1  n latest   安装官方稳定版 1  n stable   安装最新的 LTS 版本 1  n lts   安装指定版本 1  n 11.0.0   3 切换 Node 版本 查看当前已安装的 Node 1  n   并使用上下键选择版本，回车确认即可。\n4 删除某个版本 1  n rm 7.6.2   5 查看 n 模块帮助信息 1  n --help  ","permalink":"https://byteprince.com/posts/88e6ba2a/","summary":"当然采用Docker可能是另一种思路","title":"Nodejs 多版本环境管理"},{"content":" 说明 项目地址：BytePrince/Auto_Sign_For_NBU\n本项目2020.05.03前所有代码均为本人原创，自2021.01.24后更新的代码参考子墨大佬的ZimoLoveShuang/auto-submit。至于为何不再重构自己去年写的代码，文末会提到。\n本人修复了Bug，移除了不必要的代码并适配了宁波大学的每日信息填报打卡（理论上适配宁波大学所有学院）。\n如果对你有帮助，请给BytePrince/Auto_Sign_For_NBU点上一个Star⭐。\n使用方法 准备 Clone本项目\n1  git clone https://github.com/BytePrince/Auto_Sign_For_NBU.git    信息填写  在config.yml中填写自己的个人信息  示例如下：\nusers: - user: #此字段填写你的学号 username: \u0026#39;17600****\u0026#39; #此字段填写你的今日校园登录密码 password: \u0026#39;******\u0026#39; #此字段填写你的地址，即定位信息，如下图 address: 中国浙江省xx市xx区xx路 #email 接受通知消息的邮箱 email: xxxxxxxxxx@qq.com #school 学校全称 school: 宁波大学  在config.yml中填写表单信息  表单内容可能会发生变化，后期如果表单内容更新频繁的话可能会写一个表单内容自动更新API，示例如下：\ncpdaily: #表单组默认选项配置，按照说明填写即可。 defaults: #表单默认选项配置，按顺序，注意，只有标必填项的才处理 - default: #表单项类型，对应今日校园接口返回的fieldType字段，1代表文本，2代表单选，3代表多选，4代表图片 type: 2 #表单项标题 title: 1. 今日您的健康情况是?（如有发热等呼吸道症状，请第一时间报备辅导员） #表单项默认值 value: 健康 - default: type: 2 title: 今日您的甬行码颜色是？ value: 绿色 - default: type: 2 title: 今日您是否存在其他异常情况？ value: 无 - default: type: 2 title: 明日你是否有出行计划（离开居住地所在市） value: 否  在config.yml中填写通知接口信息  此处用于每天自动打卡后发送通知。由于QQ或者邮件通知配置过程对小白来说会复杂一些，将这两种通知方式移除，仅仅保留ServerChan通知。获取ServerChan的密钥的方法详见文档。\n部署 可以部署在自己的云服务器上或者直接使用云服务商的云函数。\n云函数 参考文档。（学思路，不要照抄啊喂🤪）\n云服务器（推荐） 当然，如果你手头没有云服务器，还是推荐使用云函数来执行脚本，毕竟可以省钱。\n 上传填写好个人信息的项目文件上传到你已经安装好Python3.X的云服务器；\n 进入项目根目录，安装依赖；\n1  pip3 install -r requirements.txt   手动执行脚本，测试是否可以正常运行，如果运行结果显示模拟登陆成功...，则说明环境已经配置完毕。\n1  python3 index.py   根据自己的目录，添加定时任务。笔者的项目根目录为/opt，每天下午15：01执行脚本，并作了日志的记录。\n1  01 15 * * * root /usr/local/bin/python3 /opt/index.py \u0026gt;\u0026gt; /opt/sign.log 2\u0026gt;\u0026amp;1 \u0026amp;    部署就到此结束了。\n更新日志  2021年3月23日：\n PushPlus功能波动，更换成钉钉机器人通知（钉钉机器人密钥获取请自行参考官方文档）\n 修复接口错误，默认配置为宁波大学，其他大学请自行在index.py中设定\n  设定办法：\n 访问 https://mobile.campushoy.com/v6/config/guest/tenant/list 获取本校id 访问 https://mobile.campushoy.com/v6/config/guest/tenant/info?ids=学校id 获取idsUrl、ampUrl、ampUrl2填入index.py login_url请自行设定  2021年1月30日：\n Serverchan近期服务不稳定，将微信通知改成更稳定的PushPlus  2021年1月28日：\n 修复离校签到改成常规签到了，已经修复，下载新的index.py替换原来的index.py即可，配置文件config.yml不需要变动。\n 2021年1月27日：\n 移除了冗余代码，适配了宁波大学的校外每日签到任务； 修复了今日校园更换接口导致原有接口失效的问题； 修复了今日校园修改生成算法的密钥导致Cpdaily-Extension失效的问题； 移除已失效的邮件通知功能，改为微信通知，需要调用Serverchan，配置方法详见注释； 完善了容错机制，增加了两处可能产生错误之处的告警通知； 完善了请求方式，不采用强制SSL； 完善了日志记录，去除了SSL警告； 完善了配置文件config.yml的注释，对小白更友好。   最后，说几句闲话：\n想起之前一位从事信息安全行业的朋友说过的话：通常给自己的代码做安全，不会使用强度最大的加密方法（不要试图一劳永逸），而是会选用中等强度的加密方式，并且不定时地更换加密算法，以此来增加逆向的成本而不仅仅是增加逆向的难度。\n至于为何不再重构去年的代码了，因为今日校园的工程师为了刷KPI（为了让你们自己打卡），也在不定时地维护系统（更换打卡的接口）。想来无非也是以上的道理。今日校园升级版本后，抓包有了一定的门槛（需要用到基本的计算机网络知识和一定的逻辑分析能力。当然难度也不是非常非常大，相信在座的各位只要是有学习过相关的知识，花费一定的时间（也许是两个小时，也许是两天\u0026hellip;），也可以自己从头开始写一个打卡脚本。\n可以，但没必要。毕竟，去年我是亲历者。\n所有除了感情以外的事情，切记权衡成本和收益。如有必要，及时止损。\n疫情还没有彻底结束，大家一定要做好防范措施，如果有接触高危地区高危人群，也请及时报告。这是你的责任，也是你的义务。\n最后，祝每一个看到这里的朋友，新年快乐❤️！\n","permalink":"https://byteprince.com/posts/b530bd3e/","summary":"懒人懒办法","title":"今日校园自动打卡"},{"content":" 关于Cockpity Cockpit 是一个 Web 端的系统管理工具，只用鼠标点点就能管理系统，事实上也确实如此，启动 Cockpit 服务之后，只需要鼠标点点点就能完成系统很多基础操作，比如查看系统信息，启动/停止服务，新增或者更改账户，系统更新，Web 终端及查看网络流量等功能。\n安装 某些发行版本已经默认安装，只需执行命令开机启动和添加防火墙就好。\n如果系统中没有默认安装，执行下面命令很容易安装，在 CentOS 中安装：\n 安装Cockpit。\n1  sudo yum install cockpit   设置开机启动。\n1  sudo systemctl enable --now cockpit.socket   设置防火墙。\n1 2  sudo firewall-cmd --permanent --zone=public --add-service=cockpit sudo firewall-cmd --reload    安装成功后在浏览器中输入地址进行访问：https://ip:9090。使用系统用户名、密码登录。\n禁用或注销服务 如果发行版本中默认安装，您有不想使用Cockpit，直接禁用或注销即可。\n禁用Cockpit 1  systemctl disable cockpit.socket   注销Cockpit 1  systemctl mask cockpit.socket   关闭登录后的提示 某些发行版默认安装了Cockpit，在登录后会默认提示开启Cockpit。\n通常情况下，CentOS 系统的文本登录界面中的提示信息是存放在文件/etc/motd或者目录/etc/motd.d/中。\n进入/etc/motd.d/后直接删除cockpit\n1  rm -rf cockpit    退出登录后重新登录就没有提示了。\n参考资料：\n https://cockpit-project.org/\n 《CentOS8：登录ssh提示Activate the web console》\n 《如何取消Centos 8中的Activate the web console with: systemctl enable \u0026ndash;now cockpit.socket提示》\n  ","permalink":"https://byteprince.com/posts/410ec470/","summary":"Cockpit 是一个 Web 端的系统管理工具","title":"CentOS 8 关闭 Cockpity 提示"},{"content":" 西藏自古以来是中华人民共和国不可分割的领土。\n全文整理如下：\n 江：我想，很抱歉，还要耽误你们5分钟。\n翻译：I\u0026rsquo;m sorry, I have to take up your additional five minutes.\n \n 江：我想讲讲关于达赖喇嘛的问题。\n翻译：So, I\u0026rsquo;d like to say a few words on the Dalai Lama.\n \n 江：克林顿总统他也很关心达赖喇嘛，应该说，我们的西藏从达赖喇嘛59年走了以后，整个的西藏发生了翻天覆地的变化。\n翻译：President Clinton is also interested in this question, in Dalai Lama.Actually, since the Dalai Lama left in 1959,earthshaking changes have taken place in Tibet.\n \n 江：第一，政教合一的制度从此一去不复返了,\n翻译：First, the system of theocracy has forever become bygones,\n \n 江：虽然很遗憾的，它比欧洲的 Renaissance, 这个文艺复兴之前那个政教合一，就是分开的时间要比它那个晚的多。\n翻译：but though it is unfortunate that the disappearance of this the ocracy was much later than the demise of the ocracy in Europe, before the Renaissance.\n \n 江：另外一个，在达赖政权下面的一百多（万）的农奴，解放了。我曾经90年到这个解放的农奴家里头做过客。\n翻译：And more than 1 million serfs under the rule of the Dalai Lama were liberated. In 1990, when I was inTibet, I went to visit the liberated serfs.\n \n 江：那么西藏现在实行了民族自治，有自己的人民的自己的政府。\n翻译：And now the system of national autonomy is in practice in Tibet, And the people there, they have their Tibetan autonomous region government.\n \n 江：在我到中央工作以后，我动员了我们29个省市，支持西藏，包括一些生产比较落后的，比如青海省，也要拿出钱来。大概将近80亿人民币，62个建设项目，现在建成了。\n翻译：Since I came to work in the central government, I have urged the rest 29 provinces municipalities and autonomous regions to assist Tibet in its development, even including those provinces that are not very developed, such as Qinghai province. So altogether,nearly 8 billion RMB yuan of financial resources were raised, and already 62 projects have been completed in Tibet.\n \n 江：另外，我们对西藏的宗教信仰自由，宪法有保护。对于许多的庵观寺院，包括那个拉萨有名的布达拉宫，我们花了将近一亿人民币，一吨重的金子，把它焕然一新。\n翻译：As for the freedom of religious belief，there is clear stipulations in our constitution for the protection of the religious belief, and this also including in Tibet.And we have also spent a lot of money in renovating the lamaseries and the temples in Tibet and we have spent 100 million RMB yuan and one ton of gold in renovating the Potala Palace.\n \n 江：我想，对于这个西藏来讲，达赖喇嘛，刚才克林顿总统提到的，如果说他承认，“西藏是中国不可分割的一部分”，同时呢，他必须要承认，“台湾是中国的一个省”，那么，我看我们谈判的大门是敞开着的，而且我们有若干的沟通的渠道。这一点呢，我希望，达赖他能够有积极的变化。\n翻译：Just now, President Clinton also mentioned the Tibetan issue and dialogue with the Dalai Lama, Actually, as long as the Dalai Lama can publicly make a statement and a commitment that Tibet is an inalienable part of China and he must also recognizes Taiwan as a province of China, then the door to dialogue and negotiation is open.Actually, we having serveral channels of communications with the Dalai Lama. So I hope the Dalai Lama will make positive response in this regard.\n \n 江：最后，我还要讲一句，中国的宪法对于西藏的宗教自由，包括别的，中国其他各地的，其他的宗教的自由，是保护的。但是我本人，作为中华人民共和国的国家主席来讲，我是共产党人士，无神论者，但是丝毫不影响，对于西藏的宗教自由的尊重。但是呢，我还是有一个问题，就是我去年访美的时候，也包括到欧洲的一些国家，我发现许多人，现代的文明，也是教育木平都很高，科学技术科学技术水平都很高，但是他们呢，好像还很信，这个，就是刺嘛教的教义。就这一点呢，我也正在带着一个问题，在研究，why，为什么？\n翻译：Finally, I want to emphasize that according to Chinese constitution, the freedom of religious belief in Tibet, and also in throughout China, is protected.But as the President of the People\u0026rsquo;s Republic of China, and as a member of the Communist Party, I self am an atheist.But this will by no means affect my respect for the religious freedom in Tibet. But still , Ihave a question. That is, during my visit to the United States last year and also during my previous visit to other European countries, I found that although the education and the science and the technology have developed to a very high level and the people are now ejoying modern civilization, still quite a number of them have a belief in Lamaism. So this is a question that I\u0026rsquo;m still studying and looking into. I want to find out the reason why.\n \n 江：我感觉克林顿总统，他是非常坚持美国利益的。我呢，也坚持中国的利益。但是我跟他两人，还是可以非常友好的交谈协商。这是什么？This is democracy.\n翻译：I think President Clinton is a strong defender of the American inerests and I am a strong defender of the Chinese interest. But despite that, we still can have very friendly exchanges of views and discussion.And I think that is democracy.\n \n 江：我想说明，我们有很多值得相互学习的地方。\n翻译：And I want to stress that actually there are a lot of areas in which we can learn from each other.\n \n 江：If you agree, I think, we will finish this.（台下笑）\nClinton: I agree\u0026hellip;\n 参考资料 视频来源：Youtube\n本内容基于该视频整理，仅供英语口译学习使用，请勿用于非法用途。\n转载请注明出处: https://byteprince.com\n","permalink":"https://byteprince.com/posts/69a6621d/","summary":"英语口译学习资料","title":"江泽民同志关于西藏问题同克林顿总统的讲话"},{"content":"环境配置 {% note warning %}\n此环境配置仅适用于非生产环境。 {% endnote %}\n环境简化  清除iptables规则\n1 2 3 4  iptables -L #查看iptables规则 iptables -F #清除（filter表）中所有规则 iptables -t nat -L #查看nat规则 iptables -t nat -F #清除nat规则    注：清空iptables规则后会导致ping命令不可用\n 关闭selinux\n1 2  getenforce #查看selinux状态，若为enable则关闭 setenforce #关闭selinux    环境配置 安装依赖库\n1  um -y install gcc gcc-c++ autoconf pcre pcre-devel make automake   安装工具\n1  yum -y install wget httpd-tools vim   确认yum源可用\n1  yum list|grep gcc   安装 Nginx  官方文档：http://nginx.org/en/linux_packages.html\n 可以使用官方提供的yum源，也可以使用其他yum源.\n写入Nginx仓库配置信息（可选） 新建一个nginx源配置文件；\n1  vim /etc/yum.repos.d/nginx.repo    在nginx.repo中写入以下官方提供的源信息；\n1 2 3 4 5 6 7 8  # 文档：http://nginx.org/en/linux_packages.html#RHEL-CentOS [nginx-stable] name=nginx stable repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=1 enabled=1 gpgkey=https://nginx.org/keys/nginx_signing.key module_hotfixes=true   执行yum list |grep nginx测试。\n如果可以看到\n则说明nginx源配置已经生效。\n可以直接使用以下命令安装nginx\n1  yum install nginx  ","permalink":"https://byteprince.com/posts/8d30ba6e/","summary":"","title":"Nginx 安装配置"},{"content":" 概述 Nginx是一个开源的高性能、可靠的HTTP中间件，代理服务。（关于代理服务的作用，详见三种常用的代理方式详解）\n优势 Nginx具备的是企业最常用也最需要的功能，具备轻量级性能优势。\n底层原理  采用多路IO复用epoll模型   CPU亲和（affinity）   senfile策略  Nginx在静态资源处理性能方面性能强大的原因正在于此。\n对于操作系统而言，文件需要经过内核空间与用户空间才进入socket流。而Nginx简化了这个流程：\n多路IO复用 对于多个用户请求，会产生多个Socket流，海量IO流可能使得线程处于等待状态造成阻塞\n所以采用IO复用的方式来处理，通常有以下两种处理方式：\n 多进程多线程处理  一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程（fork）要么多线程（pthread_create），但是效率都不高。\n 多路IO复用  单线程实现IO流非阻塞模式，伪代码如下：\n1 2 3 4 5 6  while true{ for i in stream[];{ if i has data read until unavailiable } }   IO复用内核模式种类 Select模型、Poll模型 select,poll模型相当于一个代理\n1 2 3 4 5 6 7  #select模型伪代码 while true{ select(streams[]){ for i has data read until unavailable } }   Epoll模型  解决了select模型对于文件句柄FD打开限制 采用callback函数回调机制优化模型效率 \u0026hellip;\u0026hellip;  劣势 Nginx具备的功能，其他服务也在采用（如Apache），功能全面性上，Nginx并不占优。\n","permalink":"https://byteprince.com/posts/1964bdb0/","summary":"底层原理简要分析","title":"Nginx 概述"},{"content":" 图的基本概念  图 有向图 无向图 简单图 多重图 完全图（亦称 简单完全图） 子图 连通图，连通分量 强连通图，强连通分量 生成树，生成森林 顶点的度（入度，出度） 边的权和网 稠密图，稀疏图 路径，路径长度，回路 简单路径，简单回路 距离 有向树  图的存储 👉🏻邻接矩阵法 一维数组存储顶点信息（将顶点编号），二维数组存储顶点间关系（二维数组存储边的信息）\n邻接矩阵 网（带权图）的邻接矩阵 存储结构定义： 1 2 3 4 5 6 7 8  #define MaxVertexNum 100 typedef char VertexType; typedef int EdgeType; typedef struct{ VertexType Vex[MaxVertexNum];///顶点表（一维表）  EdgeType Edge[MaxVertexNum][MaxVertexNum];///顶点关系表（二维表）  int vexnum,arcnum; }MGraph;   👉🏻邻接表法 邻接表是在稀疏图的情况下对邻接矩阵的一种改进，是实际中广泛采用的一种存储结构。\n结点结构 有向图和无向图的邻接表 存储结构定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #define MAX_VERTEX_NUM 20//最大顶点个数 #define VertexType int//顶点数据的类型 #define InfoType int//图中弧或者边包含的信息的类型 typedef struct ArcNode{ int adjvex;//邻接点在数组中的位置下标  struct ArcNode * nextarc;//指向下一个邻接点的指针  InfoType * info;//信息域 }ArcNode; typedef struct VNode{ VertexType data;//顶点的数据域  ArcNode * firstarc;//指向邻接点的指针 }VNode,AdjList[MAX_VERTEX_NUM];//存储各链表头结点的数组 typedef struct { AdjList vertices;//图中顶点的数组  int vexnum,arcnum;//记录图中顶点数和边或弧数  int kind;//记录图的种类 }ALGraph   👉🏻十字链表 有向图的另一种链式存储结构。可看是将有向图的邻接表和逆邻接表结合得到的一种存储方法。对应于有向图中的每一条弧有一个结点，对应于每个顶点也有一个结点。图的十字链表不唯一，但是一个十字链表确定一个图。\n好处：既容易找以 Vi 为尾的弧，又容易找到以 Vi 为头的弧==\u0026gt;容易求得顶点的入度和出度。\n结点结构 存储结构定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  typedef struct ArcNode { int tailvex, headvex; //弧尾、弧头在表头数组中位置  struct ArcNode *hlink; //指向弧头相同的下一条弧  struct ArcNode *tlink; //指向弧尾相同的下一条弧  InfoType *info; //弧相关信息指针 }ArcNode; typedef struct VexNode { VertexType data; //存与顶点有关信息  struct arcnode *firstin; //指向以该顶点为弧头的第一个弧结点  struct arcnode *firstout; //指向以该顶点为弧尾的第一个弧结点 }VexNode; typedef struct { VerNode xlist[MAX_VERTEX_NUM ] ; //表头向量  int vexnum, arcnum； }OLGraph;   图示 👉🏻邻接多重表 无向图的另一种链式存储结构。 是为了解决在邻接表中对同一条边存储两个结点而引入的一种结构。\n结点结构 其中：\nmark为标志域，可用于标记该边是否被搜索过。\nivex 和 jvex记录依附于该边的两个顶点；\nilink指示依附于ivex的下一条边。\njlin指示依附于jvex的下一条边。\ninfo 与边相关的信息。\n\n其中：\ndata存储顶点的相关信息；\nfirstedge指示第一条依附于该顶点的边\n图的遍历 👉🏻深度优先遍历(DFS） 算法思路 性能分析 深度优先生成树 👉🏻广度优先遍历(BFS) 算法思路 性能分析 广度优先生成树 👉🏻应用 图的遍历可以用来判断图的连通性。\n图的应用  图的遍历——连通性判断 有向无环图——拓扑排序 带权有向图——最短路径，Dijkstra算法  ","permalink":"https://byteprince.com/posts/538075fd/","summary":"在数据结构中，图的综合性还是比较强的","title":"数据结构 之 图"},{"content":"事务 概念 用户定义的一个不可分割的数据库操作序列。这些操作要么全做，要么不做。\n一个事务可以是一条SQL语句，可以实一组SQL语句，也可以是整个程序。事务的开始和结束可以由用户显式控制，若用户未显式定义事务，则由DBMS按默认规定自动划分事务。\n事务是恢复和并发控制的基本单位。\n事务的定义 事务的开始 1  BEGIN TRANSACTION; /*事务开始*/   事务的结束 提交或者回滚。\n1 2  COMMIT; /*奖事务中的所有对数据库的更新写回到磁盘上的物理数据库中*/ ROLLBACK; /*系统将所有已完成的操作全部撤销，回滚到事务开始时的状态*/   ACID属性  原子性（Atomicity） 一致性（Consistency） 隔离性（Isolation） 持续性（Durability）/永久性（Permanence）  其中一致性和原子性密切相关，一般情况下，事务的原子性不正常（事务被迫中断），就会导致不一致性状态。\n隔离性是指一个事务的执行不能被其他食物干扰。即一个事务的内部操作及使用的数据对其他并发事务是隔离的，并发执行的各个十五之间不能相互干扰。\n事务管理 保证事务的ACID属性是事务管理的重要任务。\n事务ACID属性可能遭到破坏的因素：\n 多个事务并行运行时，不同事务的操作交叉进行 事务在运行过程中被强行停止  并发控制 背景 多处理机系统中，每个处理及可以运行一个事务，多个处理及可以同时运行多个事务，实现多个事务真正的并行运行。这种并行执行方式称为同时并发运行（simultaneous concurrency）。并发操作可能会破坏数据的不一致性：\n 丢失修改（lost update）\n 不可重复读（non-repeatable read）\n  其中，不可重复读包括并发事务的修改，删除和插入操作。事务T2在T1读取某些数据库后删除或者插入一些记录，导致T1重复读取数据发现数据不一致，也成为幻影（phantom row）现象\n 读脏数据（dirty read）  产生上述三类数据不一致性的主要原因是并发操作破坏了事务的隔离性。并发操作就是要用正确的方式调度并发操作，是一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性。当然，为了加强数据的一致性而调度并发操作，通常会增大系统的开销，最好就是做到一致性要求内系统开销最小。\n技术 并发控制的主要技术有:\n 封锁（locking） 时间戳（timestamp） 乐观控制法（optimistic scheduler） 多版本并发控制（multi-version concurrency control, MVCC）  封锁 锁的种类  排他锁（exclusive locks），简称X锁，即写锁 共享锁（share locks），简称S锁，即读锁  封锁类型的相容矩阵 封锁协议 上述三级协议的主要区别在于什么操作需要申请封锁，以及何时释放锁（即持锁时间）。不同的封锁协议使事务达到的一致性级别是不同的，封锁协议级别越高，一致性程度越高。\n活锁和死锁 活锁 如果事务T1封锁了数据R，事务T2又请求封锁R，于是T2等待；T3也请求封锁R，当T1释放了R上的封锁之后系统首先批准了T3的请求，T2仍然等待；然后T4又请求封锁R，当T3释放了R上的封锁之后系统又批准了T4的请求\u0026hellip;\u0026hellip;T2有可能永远等待，形成活锁。\n解决活锁的简单方法 先来先服务\n死锁 如果事务T1封锁了数据R1, T2封锁了数据R2，然后T1又请求封锁R2，因T2已封锁了R2，于是T1等待T2释放R2上的锁；接着T2又申请封锁R1，因T1已封锁了R1,T2也能等待T1释放R1上的锁。这样就出现了T1在等待T2，而T2又在等待T1的局面，T1和T2两个事务永远不能结束，形成死锁。\n解决死锁的简单方法 1.预防\n 一次封锁法：要求每个事务必须一次将所有要使用的数据全部加锁（扩大封锁范围会降低系统并发度） 顺序封锁法：预先对数据对象规定一个封锁顺序（数据随时变化，维护难度大；事先规定的顺序难以实际施加封锁）  2.诊断与解除\n 超时法：以超时为标志判定死锁（容易误判；时限设置太长不容易发现思索） 等待图法：并发控制子系统周期性生成十五等待图，并进行检测，如果图中存在回路则表示出现死锁。  通常选择一个处理死锁代价最小的事务将其撤销，释放此事务的所有锁，使得其他事务得以继续运行下去，同时对撤销的事务所执行的数据修改操作必须加以恢复。\n","permalink":"https://byteprince.com/posts/80e173ac/","summary":"","title":"MySQL基础：事务处理与并发控制"},{"content":" 1 固件  版本：FriendlyWrt_NanoPi-R2S.RK3328.v19.07 来源：soffchen/NanoPi-R2S\n 备份：下载地址 密码:1234 修改后缀为.7z.001和.7z.002再进行解压。  2 软件源 1 2 3 4 5 6 7 8 9 10  #发行版软件源 src/gz openwrt_base https://openwrt.proxy.ustclug.org/releases/19.07.1/packages/aarch64_cortex-a53/base src/gz openwrt_luci https://openwrt.proxy.ustclug.org/releases/19.07.1/packages/aarch64_cortex-a53/luci src/gz openwrt_packages https://openwrt.proxy.ustclug.org/releases/19.07.1/packages/aarch64_cortex-a53/packages src/gz openwrt_routing https://openwrt.proxy.ustclug.org/releases/19.07.1/packages/aarch64_cortex-a53/routing #自定义软件源 src/gz songchenwen https://nanopi-r2s-opkg-feeds.songchenwen.com/packages   2.1 添加软件源 在 软件包 - 配置 - 自定义软件源 中添加如下一行\n1  src/gz songchenwen https://nanopi-r2s-opkg-feeds.songchenwen.com/packages/   2.2 添加签名公钥（可选） ssh进入安装有OpenWrt的路由器，执行\n1  mkdir -p /etc/opkg/keys; wget -qO /etc/opkg/keys/5e99c2573f29d764 \u0026#34;https://nanopi-r2s-opkg-feeds.songchenwen.com/keys/5e99c2573f29d764\u0026#34;   或禁用签名检查，在 软件包 - 配置 中删掉这一行 option check_signature 1\n2.3 第三方软件源 ①NanoPi R2S 专用软件源\n（参考：宋辰文的博客 NanoPi R2S 专用软件源 )\n1  src/gz songchenwen https://nanopi-r2s-opkg-feeds.songchenwen.com/packages/   ②kuoruan_universal源\n1  src/gz kuoruan_universal http://openwrt.kuoruan.net/packages/releases/all   以上两个源适用FriendlyWrt系统，且已经过测试。添加源后执行以下命令即可。\n1  opkg update   ③V2ray源\n kuoruan/openwrt-v2ray luci-app-v2ray （NanoPi R2S适用，添加该源后也可以安装luci-app-ssr-plus和luci-i18n-ssr-plus-zh-cn）  2.4 opkg包管理 1  opkg update  1  opkg install   1  opkg remove   使用opkg命令卸载插件后若插件还在插件列表中，尝试清除/usr/share目录下与插件相关的残留文件。\n3 Cron备份  专治锐捷。\n 0 * * * * /usr/bin/python3 /login/detect.py \u0026gt;\u0026gt; /login/conn.log 2\u0026gt;\u0026amp;1 \u0026amp; 脚本备份下载：Pwner\u0026rsquo;s Pan\n","permalink":"https://byteprince.com/posts/9ed4e0b0/","summary":"提供科学上网服务以及校园网断线重连","title":"NanoPi R2s 配置备份"},{"content":"使用密码口令登录服务器会有两个问题：\n 安全问题，容易产生口令泄漏等安全风险 口令较长，每次都需要输入口令较为繁琐  基于此，总结下解决方案。\n口令较长的问题可以用sshpass来解决每次都需要输入长密码的烦恼，但是使用sshpass是极其不安全的，因为所有系统上的用户在命令行中通过简单的 ps 命令就可看到密码。\n所以，目前较为安全的SSH登录验证方式还是采用密钥登录。\n环境  Win 10 CentOS 7 Windows Terminal等命令行工具  Windows配置 生成SSH密钥 查看用户目录/.ssh 目录，如果有id_rsa.pub和id_rsa文件，则此步跳过。\n否则执行以下命令生成密钥。\n1  ssh-keygen -t rsa   其中id_rsa.pub为公钥，id_rsa为私钥。\nCentOS配置 添加公钥 以root用户为例，其他用户操作类似，只需要将操作目录换成目标用户目录即可。如用户为zhangsan，则只需要将~/（即/root/）换成/home/zhangsan/就可以。\n1 2  mkdir ~/.ssh touch ~/.ssh/authorized_keys   上传在Win10 生成的公钥文件到 CentOS 并追加内容到 authorized_keys\n1 2 3  scp .\\id_rsa.pub root@192.168.0.2:~/ cat ~/id_rsa.pub \u0026gt;\u0026gt; ~/.ssh/authorized_keys rm ~/id_rsa.pub   重启SSH 1  systemctl restart sshd   修改目录权限 1 2  chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys  ","permalink":"https://byteprince.com/posts/65eb32e5/","summary":"","title":"使用密钥登录服务器的配置"},{"content":" PlantUML 是一个开源项目，支持快速绘制： 时序图、用例图、类图、活动图、组件图、状态图、对象图、部署图、定时图，同时还支持以下非 UML 图: 线框图形界面、架构图、规范和描述语言 (SDL)、Ditaa diagram、甘特图、思维导图、WorkBreakdown Structure diagram、以 AsciiMath 或 JLaTeXMath 符号的数学公式、Entity Relationship diagram\n通过简单直观的语言来定义这些示意图,与 MarkDown 有相似的作用，这两种语言一个主要面向文本渲染一个主要用于图形绘制。\n环境准备  VSCode PlantUML插件  语法 参考：官方文档\n例子 @startuml skinparam dpi 1000 #指定图片分辨率，如果不指定，默认的参数导出的图片放大以后会比较模糊 scale 13500 width #指定图片的高度和宽度 scale 2200 height 用户 -\u0026gt; 认证中心: 登录操作 认证中心 -\u0026gt; 缓存: 存放(key=token+ip,value=token)token 用户 \u0026lt;- 认证中心 : 认证成功返回token 用户 -\u0026gt; 认证中心: 下次访问头部携带token认证 认证中心 \u0026lt;- 缓存: key=token+ip获取token 其他服务 \u0026lt;- 认证中心: 存在且校验成功则跳转到用户请求的其他服务 其他服务 -\u0026gt; 用户: 信息 @enduml 文件格式 .wsd, .pu, .puml, .plantuml, .iuml\n预览 Alt+D\n导出 可以导出为png、svg、eos、pdf、scxml、html、txt、utt、latex、latex:nopreamble 等格式，方法如下:\n F1 或者 Ctrl+Shift+P PlantUML:导出当前图表； 选择导出格式png；导出即可。  ","permalink":"https://byteprince.com/posts/ca02613b/","summary":"PlantUML","title":"使用 VS Code 插件绘制流程图类图组件图"},{"content":" Linux用户文件权限 chmod Linux chmod（英文全拼：change mode）命令是控制用户对文件的权限的命令\nLinux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。\n只有文件所有者和超级用户可以修改文件或目录的权限。\n权限的三种表示方法    十进制 权限 rwx 二进制     7 读 + 写 + 执行 rwx 111   6 读 + 写 rw- 110   5 读 + 执行 r-x 101   4 只读 r\u0026ndash; 100   3 写 + 执行 -wx 011   2 只写 -w- 010   1 只执行 \u0026ndash;x 001   0 无 \u0026mdash; 000    对应的示意图：\n语法 1  chmod [-cfvR] [--help] [--version] mode file...   参数说明 mode : 权限设定字串，格式如下 :\n1  [ugoa...][[+-=][rwxX]...][,...]   其中：\n u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限，- 表示取消权限，= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。  其他参数说明：\n -c : 若该文件权限确实已经更改，才显示其更改动作 -f : 若该文件权限无法被更改也不要显示错误讯息 -v : 显示权限变更的详细资料 -R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) --help : 显示辅助说明 --version : 显示版本  实例 将文件 file1.txt 设为所有人可读取 : 1  chmod ugo+r file1.txt   或\n1  chmod a+r file1.txt   将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : 1  chmod ug+w,o-w file1.txt file2.txt   将 ex1.py 设定为只有该文件拥有者可以执行 : 1  chmod u+x ex1.py   将目前目录下的所有文件与子目录皆设为任何人可读取 : 1  chmod -R a+r *   此外chmod也可以用数字来表示权限如 : 1  chmod 777 file   用户组管理 1  chown -R git.git /var/www/blog/ #授予git.git为/var/www/blog/的管理者   查看当前目录下所有文件的用户组和权限 1  ls -al   Git用户权限控制 赋予Git用户sudo权限 1  chmod 740 /etc/sudoers  1  vim /etc/sudoers   可以看到以下内容：\n1 2  # User privilege specification root ALL=(ALL:ALL) ALL   在 root ALL=(ALL:ALL) ALL 这一行下面添加 {Git用户名} ALL=(ALL:ALL) ALL\n保存退出后，修改回文件权限：\n1  chmod 440 /etc/sudoers   关闭Git用户shell权限 1  vim /etc/passwd   将最后一行的 {git用户名}❌1001:1001:,,,:/home/git:/bin/bash 修改为 {git用户名}❌1001:1001:,,,:/home/git:/usr/bin/git-shell\n，也即将/home/git:/bin/bash改为/home/git:/usr/bin/git-shell\n使用密钥进行SSH登录（免密码） 1 2 3 4  cd /home/{账户名称} //切换到需要修改的账户的用户目录 mkdir .ssh //创建.ssh目录 cd .ssh vim authorized_keys   然后将本地的公钥复制到服务器的 authorized_keys 文件里 (本地的公钥即本地执行 cat ~/.ssh/id_rsa.pub 查看的内容，若无法运行则需创建)。\n注意：收集所有需要登录的用户的公钥，就是他们自己的 id_rsa.pub 文件，把所有公钥导入到 /home/git/.ssh/authorized_keys 文件里，一行一个。\n配置好密钥后，就可以免密码直接用ssh登录账户了。\n如果有必要，还应该关闭所有用户的密码登录，选择密钥登录，并使用跳板机，fail2ban等工具来加强安全性，并定期检查账号登录日志，防患于未然。\n","permalink":"https://byteprince.com/posts/98968786/","summary":"对于生产环境的服务器来说，用户的权限控制是十分必要的","title":"服务器安全之 Git 用户权限控制"},{"content":"\n今天收到了阿里云赠送的限量马克杯，纪念2009年北京上地，阿里云第一行代码的诞生。\n2020.08.20\n","permalink":"https://byteprince.com/posts/c176bc4b/","summary":"","title":"收到了阿里云第一行代码限量纪念马克杯"},{"content":" 标题和正文样式 创建样式 最主要的三个设置内容：后续段落样式、字体和段落。\n重新定义样式 定义多级列表 图片表格自动编号 效果：\n参考文献 如何插入参考文献？ ​ 将光标定格在需要插入文献标记的位置，然后点击引用-\u0026gt;插入尾注，就可以了。\n要记得选中所有的尾注，使用查找和替换功能，寻找所有^e的字符，替换成 [^\u0026amp;]。\n如何给尾注编号加上方括号？ 方法：直接在将光标移到正文尾注前，切换“上标”，就可以直接添加方括号了。\n尾注上方的横线怎么删？ 尾注后一页的页眉横线怎么删？ 把光标移到尾注之前，然后插入——分隔符——分节符-下一页，然后全选中尾注的内容，右击选择便签选项，设置为尾注——节的结尾！就OK了！\n","permalink":"https://byteprince.com/posts/360145af/","summary":"一些比较实用的Word排版技巧","title":"论文排版常用技巧"},{"content":" Hexo 是一个便捷的静态博客系统，最方便快捷的方案就是部署到 GitPage 上。但是 GitPage 的服务器位于境外，如果没有加 CDN 的话，国内用户访问 GitPage 的速度普遍较慢，而且国内搜索引擎对基本不（能）抓取 GitPage 上的内容，影响网站的 SEO。\n环境  带Git环境的 ECS（以 CentOS 为例） 本地Hexo环境（Node.js等） 已备案域名等其他必要的东西  原理 示意图\n创建仓库 在 ECS 上，检查 Git 环境，创建 Git 仓库\n1 2  mkdir blog.git \u0026amp;\u0026amp; cd blog.git git init --bare   其中git init --bare指令的作用是创建一个裸仓库。裸仓库与普通git仓库不同，普通git仓库包含所有可操作性的项目文件和.git目录，而裸仓库只包含commit的版本信息。简便起见，这里直接创建裸仓库。\nHexo配置 1 2 3 4 5 6  deploy: - type: git #git仓库路径 repo: root@xx.xxx.xxx.xxx:/www/blog.git #分支 branch: master   插件安装 1  npm install hexo-deployer-git --save   该插件的作用是执行deploy的时候，将 Hexo 生成的静态文件提交到 Hexo 的_config.yml配置的deploy.repo地址。如果已经成功部署到 GitPage 过，该插件一般都默认安装了，可以执行该命令检查、更新插件。\n自动部署 创建钩子 进入 Git 仓库/hooks目录，并创建钩子post-receive。\n1 2 3  cd /www/blog.git/hooks touch post-receive vim post-receive   然后输入以下内容\n1 2 3 4 5 6 7 8  #!/bin/bash -l GIT_REPO=/www/blog.git TMP_GIT_CLONE=/www/tmp/blog PUBLIC_WWW=/www/wwwroot/byteprince.com rm -rf ${TMP_GIT_CLONE} git clone $GIT_REPO $TMP_GIT_CLONE rm -rf ${PUBLIC_WWW}/* cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}   其中/www/blog.git为仓库路径，/www/wwwroot/byteprince.com为博客网站路径，/www/tmp/blog是临时目录。\ngit会先将文件拉到临时目录，然后再将所有文件拷贝到博客网站目录/www/wwwroot/byteprince.com。\n保存后退出。\n更改目录权限 更改网站目录权限\n1 2  chmod +x post-receive chmod 777 -R /www/wwwroot/byteprince.com   运行 每次写完博客，在本地博客目录下运行hexo g -d即可。可能需要输入远程访问服务器的密码。\n出现以下提示说明部署成功。\n1 2  ... INFO Deploy done: git  ","permalink":"https://byteprince.com/posts/934eaeda/","summary":"将Hexo博客部署到阿里云ECS","title":"Hexo 提速：自动部署到 VPS"},{"content":" Typora 是一款很优秀的 Markdown 编辑器，在更新版本0.9.84后，可以结合 PicGo 实现图片自动上传到图床，节约手动上传图片到图床的时间。\n环境  Typora版本不低于0.9.84 PicGo  使用方法 1.PicGo -\u0026gt; 图床设置，选择对应的图床服务商，并填写存储桶，秘钥等信息。\n2.设置 PicSever 并开启。\n3.打开 Typora - 文件 —\u0026gt; 偏好设置，完成以下设置。\n4.在 Typora 中愉快地写作~\n 方法一：使用快捷键Ctrl+Shift+I,选择图片插入 方法二：直接将图片拖入编辑器区域  使用以上两种方法，图片直接被上传到图床并以外链的形式插入到文档中\nPerfect！👍\n","permalink":"https://byteprince.com/posts/e3b03f1d/","summary":"推荐一款很好用的图床管理工具","title":"Typora + PicGo 实现图片自动上传图床"},{"content":"本地环境要求：Git\n上传 1.新建远程仓库 创建仓库的注意点：\ngitignore: 不需要进行版本管理的仓库类型，对应生成文件.gitignore\nlicense: 证书类型，对应生成文件 LICENSE\n2.使用命令上传 ①右击待上传的项目文件夹，选择Git bash here\n1  git init   随后项目文件路径下会多出一个.git文件夹，用来保存 git 传输的一些信息\n②将项目上所有的文件添加到仓库中。\n如果想添加某个特定的文件，只需把.换成这个特定的文件名即可，中间以空格隔开。\n1  git add .   ③填写对本次 commit（提交）的注释\n1  git commit -m \u0026#34;xxxxxx\u0026#34;   ④本地的仓库关联到 Github 上\n1  git remote add origin https://github.com/BytePrince/xxxxxxx.git   ⑤代码上传到 Github 仓库\n1  git push -u origin master   执行完后，输入账号密码确认身份即可。\n更新 1.选中项目文件夹，进入 bash。如果想更新某个特定的文件，只需把.换成这个特定的文件名即可。\n1  git add .   2.填写对本次 commit（提交）的注释\n1  git commit -m \u0026#39;xxxxxxxxxx\u0026#39;   3.提交到原始的 master 分支\n1  git push origin master   回滚 本地项目回滚到 Github 仓库内的某个版本 1.选中项目文件夹，进入 bash\n2.查看提交日志\n1  git log   3.选择需要回滚的版本，并记录其 hash\n4.按Q返回命令行模式，使用命令，将本地项目回滚到仓库里指定的版本\n1  git reset --hard xxxxxx(hash)   Github仓库内的项目回滚 一般有两种思路，①新建分支，从分支回滚到 master；②回滚项目到本地，从本地重新 Pull。\n这边采用后者。\n按照上述，将历史版本回滚到本地，随后推送到仓库。\n1  git push -f -u origin master   1  git Pull  ","permalink":"https://byteprince.com/posts/4daf64c3/","summary":"","title":"Github 基本使用方法"},{"content":" 2019余额仅剩不到0.27%，明天开始就是新的一年2020了。遂将这一年的记忆付诸图文。来日翻起定是余味无穷。\n 2019.02.05 正月初一，今年的第一部电影。按照每年的惯例，都会和家人一起去看贺岁片 \n2019.02.15 沈工和圃哥应该是快要返校了，分别前的聚首，公交上碰巧遇到钱老师，虽然没教过我，还是攀谈了两句 \n2019.02.15 没记错应该是沈工200块钱买的游戏币，抓了这些娃娃 \n2019.03.08 拿到国交学院服务器root权限，开始帮国交学院更新和维护其网站服务 \n2019.03.14 傍晚在甬餐三楼随手一拍 \n2019.03.15 和某人的饭局，但好像吃得不是很开心 \n2019.04.20 生日那天随手一拍，已是春意盎然 \n2019.04.23 两位老伙计寄来的生日礼物，圃哥的日本杯子至今还没用，一直在木盒里装着，逼格太高 \n2019.05.11 学校十佳歌手演出：唱功都很棒，晚风微凉 \n2019.05下旬 睡眠很不好，心情烦躁，搬去X兄寝室住了几晚，但睡眠似乎没有什么改善 \n2019.07.01 暑期开始在宁波轨道交通集团实习，为期两个月 \n2019.07.26 雨后的傍晚，下班回到学校 \n2019.7.24 制作了人生中第一支正儿八经的vlog \n2019.07.28 周末加班，宁波轨道交通集团三楼还是五楼俯瞰，天很蓝 \n2019.07.30 收到了吾爱破解论坛赠与的十一周年庆礼物，从年初加入吾爱管理团队已经半年啦 \n\n2019.07.31 从学校到外滩大桥的骑行，将近20公里，但是没有感觉到累，身体状态还不错 \n2019.08.03 又在公司加班，雷阵雨前的景象（公司大楼视野很不错） \n2019.08.03 自己挣钱买下来了人生中第一份苹果套装 \n2019.08.09 台风天，从公司下班到学校的场面，雨伞都撑不住... \n2019.08.23 结束为期四十五天的暑期实习工作，傍晚雨后恰好看到了彩虹 \n2019.10.07 去杭州找两位玩了十多年的兄弟，因为时间比较赶，没来得及去ZJU，在HZNU聚首 \n2019.10.24 参加全国大学生马拉松联赛 跑的依旧是迷你赛程竞赛组，事情比较多，身体状态不佳，但还是坚持下来了。去年六月份的全国马拉松联赛跑进前三十名，今年几百名开外了（但是登上了学校公众号推送的视频封面，哈哈哈哈）  2019.11 因服务器停止续费，致力于提供免费影视资源的丁丁电影站暂时下线，深刻体会到用爱发电的不容易，感谢网站建设过程中沈工，圃哥等人的付出，希望来日能东山再起 \n\n2019.12.31 甬江餐厅三楼 破旧的台球桌 九月初在健身房健身之余从零开始练习台球，从一颗球进不了到现在，多次击败我未曾赢过的对手，感谢甬餐李老师的指点。不光是击球动作，控球思路，在心理状态方面，也帮助了我很多，同时也感谢陪我练球的J哥，今天中午被我6:3横扫，稍微得意一下哈哈哈。 球如人生。台球这项运动的魅力在于，你的基本功（击球动作，基本塞点，控球准确性），每次出手所做的选择（走位），心理状态（逆风翻盘的极大可能）。出杆击球的瞬间，眼睛看的是母球还是目标球，没有一个准确的说法。甚至每个世界级水平的台球大师都有自己的习惯。有的人喜欢看母球，有的人喜欢母球和目标球交替看，生活也当是如此。只着眼于当下，未免太局促，若失去了远方，当下的一切再精准也不过是无的之矢。只远看目标，忽视了对母球的掌控，击球动作不不稳，能不能达成目标不说，呲杆就成了家常便饭。\n2020，希望自己可以更有自信，更果断，更有毅力。\n","permalink":"https://byteprince.com/posts/1b65258a/","summary":"记录一下几件事","title":"2019的记忆"},{"content":" 最近笔者在网上看到，DIY 华为的“一碰传”功能相当火爆。本人身为虔诚的“菊花粉”，同时又爱好 DIY，自然不会放弃这个好机会。参考了相关的资料后，顺利使用自备的 NFC 贴纸实现华为一碰传的功能，特此总结，提供给想要 DIY 或者 DIY 失败的朋友进行参考。\n华为“一碰传”简介 华为一碰传的功能简介不再赘述，这些在华为官网都可以看到。以下是官网称实现一碰传和多屏协同需要的硬件支持：\n从上图可以得知，华为一碰传实现的主要硬件载体就是手机的 NFC 模块和电脑的 NFC 标签。在这个 DIY 的过程中，华为 Mate Book 本身就并不是必备条件，我们完全可以通过自己的 NFC 空白芯片来模拟，当然，一个具有 NFC 读写功能的华为手机是必需品。另外，既然是华为自家的生态才可以直接使用这个功能，自然在 NFC 的读写中肯定会引入相关的参数来区别华为笔记本电脑和非华为笔记本电脑，这个在后续的操作中会体现。\nDIY华为一碰传需要做的准备 ①一台具有 NFC 模块的华为手机（多屏协同要求手机系统版本不低于 EMUI10/Magic UI 3.0）\n②一台具有 5G WIFI 和蓝牙功能的电脑，显卡支持 HEVC\n③NFC 标签贴纸（NTAG312/NTAG215 等均可）/空白的 IC 卡\n\n模拟华为一碰传的思路 目前有不少教程了，但是写的都太过于详细导致让新手很难抓住重点，这里可以让你在操作的时候思路更清晰。\n1.手机端安装一碰传助手，PC 端安装华为电脑管家；\n2.在执行一碰传或者多屏协同任务的时候，华为电脑管家会通过 SN 值来检测是否是华为电脑，若非华为电脑则无法执行任务。通过伪装 SN 值来“欺骗”华为电脑管家，就是本次破解的核心（通过注入util.dll来实现）\n3.在华为电脑管家安装包中提供了两版 dll，根据前人的经验，电脑 SN 值小于大于16位的可以通过直接注入util.dll来实现，而 SN 小于16位的则需要通过伪装 SN 或者修改 SN 来实现。\n具体操作流程 1.下载华为电脑管家安装包，解压 PCManager_Setup_10.0.2.59.zip 进行安装\n2.号文件到电脑上，安装完成之后无法打开运行，需要进行 dll 注入才可以正常打开，注入 dll 的方法如下：\n首先打开任务管理器停止华为电脑管家的服务，\n一般刚安装好的只有 MBAMainService 服务。启动过多屏协同之后会出现 LCD 服务将“无需伪装 SN 版 dll “文件夹中的 Util.dll 替换到电脑管家的程序目录，替换成功后返回任务管理器启动刚才停止的两个服务或者直接重启电脑。\n重启后就可以双击桌面上的华为电脑管家图标正常打开华为电脑管家了。\n\n查看序列号的位数（包含空格），如果序列号的位数大于16，则可以不用伪装或者修改SN，反之则需要。\n3.【SN 号大于16的可以直接跳过此步骤】伪装 SN/修改 SN 的方法：\n①伪装：\n复制华为电脑管家安装包中“伪装 SN 版所需 DLL ”进行替换（方法同步骤2，先在仍无管理器中停止华为电脑管家的相关服务后进行替换，替换后重启服务或者直接重启电脑），该版本dll支持识别伪装的SN码。\n管理员运行 Powershell 进行新增伪装 SN 码，步骤如图：\n\n\n\n\n\n\n如图所示，伪装版本的 SN 码就已经增加完毕\n\n接下来用伪装的 SN 码生成二维码，进行制作 NFC 标签即可，以图中伪装的二维码为例，对应字符串为 SN=5EKPM18320000397|MAC=98541B2E6877|MODELID=00000505\n②修改：\n不建议使用修改 SN 的方式，因为修改 SN 可能会影响电脑的保修，故不再赘述。如果在了解这个风险后还是想要尝试，可以百度如何使用DmiEditWinGui修改 SN。\n4.获取本地蓝牙 Mac 地址\n\n构造字符串SN=5EKPM18320000397|MAC=98541B2E6877|MODELID=00000505\n将步骤3中生成的字符串转成二维码（在线转二维码工具），使用华为一碰传助手扫描生成的二维码，根据手机上的提示激活 NFC 标签即可。\n\n\nEnjoy it 以后，你只要打开手机的 NFC 功能并轻触 NFC 标签，就可以和电脑进行快捷连接，连接后就可以进行愉快的一碰传和多屏协同的功能了~\n 总结 华为的一碰传和多屏协同是华为生态中重要的一步。虽然这个方式并不一定适合每个人的使用习惯，但是深度体验华为多设备文件传输同步功能后还是感触颇深。作为代表当今中国科技实力的企业之一，华为正在逐渐缩小和苹果，谷歌等世界超一流公产品的差距，衷心希望华为的产品可以越来越优秀。\n","permalink":"https://byteprince.com/posts/462dd14b/","summary":"Dell G3 + Honor Magic 2","title":"用 NFC 贴纸实现华为一碰传"},{"content":"地球绕着太阳被称为年的轨迹。曾经相遇到分开它转了三圈。一切早已和着时光机的轰烈声响呼啸远去了，似乎什么也留下。\n初春，暖风。在这样的四月里，若有若无的伤感蛰伏在空气中的某个角落，只等待某个不经意间的时刻钻进心里，留给我们无法言语的疼痛。往事开始泛起泡沫。\n【 Part I 毕业照 】\n那是一个周三的下午，阳光任明媚，白晃晃地照着听松园。两旁花坛中的桂树头上冒出了几缕青翠的嫩芽。\n排着队伍等待。四周都是再熟络不过的景象。此时的场景与周一集会时相似。每个人脸上都弥漫着温暖。但在人头攒动的热闹中，我却嗅到了淡淡的哀伤。\n飞机划过苍穹，然后在原本一尘不染的天空留下一道稀薄的带子。望着天空的时候，突然想到了六月，想到了“在地狱仰望天堂的样子”，在那个硝烟弥漫的季节，时间推着我们一步一步走向硝烟弥漫的战场。这是多么残忍的事实。可是我们终究要鼓起勇气去面对。\n排在前面的班级很快就好了，轮到我们的时候一群人排着队走上了台阶。站在上面，逆着光，却有种悲凉的感觉。背景是校园的大门斗，三个大字下面的翻译“Charming Sound Yard”曾被我们讨论过许久。灼热的阳光让我们每个人都有了夏日特有的表情。在一片校服荡开的红色中，微微皱起眉头，几乎成为毕业照上最常见的细节。\n【 Part Ⅱ 食堂 】\n现在依然会在每天中午放学后和三个最要好的朋友以百米冲刺的速度穿过曲院的长廊，冲到食堂，排在固定的九号窗口，买菜打饭，每天单调却依然喜欢的菜式。有时候速度慢了一点，会被食堂大厅里那些长长的队伍吓到。但窗口的大妈热情友好，动作之迅速足见功底，这倒又给了几分安慰。\n恍惚之间又回到了初中。毕业后我们不会再看到他们，可他们依旧在那里迎接着一批又一批学生。就像操场边的榕树，静静地伫立，历经一年复一年。\n怀想那些迷上了干菜饼的冬日，爱睡懒觉的我愣是每天坚持5：30起床，只等宿管阿姨开门的瞬间，跑向食堂去，抢那刚出炉的脆饼。天还是阴沉沉的黑色，坐在视角极好的二楼餐厅，边咀嚼着美味的酥脆感，一边看着窗外：光线从山头的天空越过，然后慢慢渗进食堂。天色一点点明亮起来。久久注视，像虔诚期待神灵赐福的信徒，又像是等待一个生命的新生。\n【 Part Ⅲ 宿舍 】\n白马湖畔，有几垄不大不小的土地。豌豆，南瓜,冬瓜，芹菜，茄子，每个季节，土地上都会荡开不同的色彩。抬头是天空，偶尔掠过鸽群。\n四幢宿舍楼依靠在土地边，只隔着一层铁丝网，但夏日总有调皮的丝瓜藤，翻越围网，在楼与楼之间的草坪上诞下属于它自己的果实。站在阳台，可以望见那几只丝瓜从夏日的肥硕到深秋的枯黄，看着丝瓜这样成长。都说时间会冲淡一切，其实一切都是时间铸就的。\n那个秋日的雨夜，和两三室友，并排坐在阳台上，透过齐密的雨幕，看那闪电不时将如漆般的黑色夜空刺穿。直到后来，实在禁不住风的纠缠，连打数个喷嚏后，关上阳台的玻璃门，各自回床上躺了。但玻璃门的隔音效果着实不佳，我辗转反侧，大抵是雨水打在大地上的声音急促。想起了水气氤氲的宋朝，赵师秀约友对弈，在水墨烟雨之中，青草地里传来的高高低低的蛙声，友人还没有来，时间一晃就过了午夜，手执棋子转向桌面，等着客人，只看到灯芯，过一会儿，就落下一截……也莫不如此般孤寂的夜晚，只恐怕同室的兄弟，在多情的雨声里，也睡不着吧。\n住进宿舍的学生一届一届不断，不变的是宿舍里上演了的那些故事。一群穿着裤衩的男生一起趴在冰凉的栏杆上，仰望北斗七星，直到黎明。冬天，熄灯后几颗脑袋聚在一起，几碗热气腾腾的泡面，啃着鸡爪，喝着面汤，我们吃得“一把鼻涕一把泪”。很多很多章节，被拉进青春的记忆里，然后成为永不褪色的经典。\n【 Part Ⅳ 教室 】\n很久以后的现在，我还是会记起这些风淡云轻的日子。阳光穿过玉兰树的枝桠斜斜地照射进来，黑板上留下了一块又一块斑驳，随着树枝的摇曳，那些光板也变得光怪陆离。老师的脸隐没在光线的交错中。空气中浮动的粉笔灰，化学给了一个专有名词叫做丁达尔效应。化学老师说这是胶体特有的性质。而我觉得，这是光与尘的曼舞，一次美妙的邂逅。\n初一时的自己在每节课上都规规矩矩地听着老师讲课，看着粉笔在黑板上唧唧喳喳的写着。\n初二时胆子大了一点，开始在上课的时候嚼糖果，在无聊的课上看《幻城》，在幻想的王的世界里游走。\n初三时，迫于时间的压力，开始改邪归正，拼了命弥补前两年晃荡时遗落的知识。\n初三，是最忙，也是记忆最深刻的一年。我想那时每个人的课桌上都留下了属于自己的印记。King的桌面上那根戴着眼镜的可爱香蕉，“今日惊蛰”的篆刻，还有课桌边上各种形状和图案的挂钩……一张课桌就是一个舞台。\n在那个教室里，上了三年课。也曾拥有老俞课上的哄堂大笑，有过 Miss Ding 的妙语连珠，有过安静的瞬间，有过吵闹的时候。透过教室北面的窗户可以毫无阻挡地望见校门，看着相聚和分别在这里一年又一年地上演。\n犹记数学老赵总挂在嘴边的那句马云的名言“今天很残酷，明天更残酷，但后天很美好。大多数人死在明天晚上，看不见后天的太阳。”在高考压力下努力学习的今天，想来这句话依旧甚是有味。\n我们都是渡河的人，而老师就是那辛勤的摆渡者。日复一日，年复一年，直到满鬓映残阳。\n【 Part Ⅴ 我们 】\n钟表可以回到原点，却已不是昨天。\n有人曾说，我们是幸运的一届，因为三年里，大雨，洪水，大雪，都被我们遇上了。\n江南水乡，湖畔山坳，雨水自然是格外充沛。九月里，迟迟不肯离去的夏季风终于无可奈何地走了，却恰好迎上了那冷气团，雨便开始无休无止地瓢泼。每天早上蹚着水去食堂，再蹚着水到教室上课，晚上还要继续蹚水回寝室。楼道里满是拖鞋趿拉着漫步的欢唱声。撸起裤管，在积水带来的“游泳池”里享受大海般的温顺抚摸。更有甚者，不知道从哪里弄来一副羽毛球拍，在那知道膝盖深的水里，开打了。为了接住每一个飞来的球，总会有摔倒的时候，屁股和腿便完全浸在“池”里，站起来后，已颇似没脱裤子洗了个澡。\n那几天的大雪纷飞。整个操场在一个下午的积淀后变成了洁白的海洋。下课的铃声终于响了。随着追逐的步伐和飞舞的雪花，一长串一长串脚印深深地烙在了雪地里。晚上洗漱后，裹紧被子，打着手电聊天。外面呼啸的猎猎的风震得门窗噔噔地摇晃。\n最后，一张张同学录开始像传单一样在你我之间传递。浩在给我的同学录上却只留下了寥寥数字。或许你不喜欢形式上的怀念，因为形影不离，反而在分别的时候无法提笔下下反复的思绪。\n班主任捧来一叠厚厚的毕业证书，一本，一本，直到都有了归属。我们坐在自己的位子上，那些有过的争吵，那些亲切的关怀，那些真正的朋友，那些流过的眼泪，那些喜欢过的女孩，那些不知所措的青春岁月，一下子都远离，变成了往事。一转眼三年就过去了。我心里有瞬间的失落，空空荡荡，无法平复。\n初中三年，留给我很多很多一言难尽的回忆。读过的书，走过的路，听过的歌，释放过的压抑，触碰过的快乐，遗失的美好。一切的一切都已成为繁芜的花朵盛开在我的眼睛里。、\n时间的尘埃掩埋了诸多过往。可我还是会想起那时的情景，整个人都被一种叫友谊的光芒炙烤着。烦乱无序的画面浮光掠影般出现在生命里，又将悄然离去。不知道若干年后，想起这三年，会不会因为这陌生而又熟悉的一切再次黯然神伤？\n 后记\n​ 相聚太短，回忆很长。湖畔三年，一起走过。谨以此文，献给那些平凡而又精彩的日子，惟愿我们的舞台永不落幕。\n ​\n​ 本文创作于2016年2月21日\n​ 今天在第一餐厅玻璃窗看到渐斜的夕阳，想起六年前在白马湖边的食堂里，也是这样的玻璃窗，看着晨曦\n","permalink":"https://byteprince.com/posts/7a035124/","summary":"本文曾获冰心青少年文学大赛二等奖","title":"浮光掠影"},{"content":"查看系统版本 1  cat /etc/redhat-release   查看内核版本 1  uname -r   查看 Linux 系统信息（内核信息\u0026amp;GCC Version） cat /proc/version 修改主机名 vi /etc/hostname 修改后重启即可。\n修改用户名 第一步：登出要修改用户名的用户（没有注销登录的用户无法修改） 第二步：以 root 身份登录终端，进行如下操作： 1  vim /etc/passwd # 修改用户名 和 用户根目录   找到要修改用户的配置行，将这行出现的centos 全部改为 laizili（根据自己实际情况改变）\n1  vim /etc/shadow # 做法同上  1  vim /etc/group # 修改用户组，将用户组名改为新用户名，操作类似上步.  1  mv /home/centos /home/BytePrince # 最后，修改用户根目录名   切换 Linux 源 切换 yum 源可以提高 yum 包下载速度，如果使用云服务器，可以考虑将 yum 源改成内网源。\n下方以切换成阿里云公网源为例。\n备份原 repo 1  cd /etc/yum.repos.d/  1  mkdir repo_bak  1  mv *.repo repo_bak/   下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ 1  wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo    如果下载失败，可能需要修改DNS/etc/resolv.conf文件\nnameserver 8.8.8.8 #google域名服务器\nnameserver 8.8.4.4 #google域名服务器\n 清除缓存，生成新的缓存 1  yum clean all   1  yum makecache    安装 Nginx sudo apt install nginx 确认：查看端口 netstat -anp |grep 80 或\nsudo lsof -i:80 确认：查看 nginx 服务 安装 PHP sudo apt install php php-fpmsudo apt-get install php7.2 php7.2-fpm 查看 php 版本 php -v 确认：查看进程 ps -ef |grep php","permalink":"https://byteprince.com/posts/04fcd332/","summary":"","title":"CentOS 常用命令和问题解决"},{"content":" Print()函数的高级用法 通过help(print)命令可以查看到详细的帮助信息\n Help on built-in function print in module builtins:\nprint(\u0026hellip;) print(value, \u0026hellip;, sep=\u0026rsquo; \u0026lsquo;, end=\u0026rsquo;\\n\u0026rsquo;, file=sys.stdout, flush=False)\nPrints the values to a stream, or to sys.stdout by default. Optional keyword arguments: file: a file-like object (stream); defaults to the current sys.stdout. sep: string inserted between values, default a space. end: string appended after the last value, default a newline. flush: whether to forcibly flush the stream.\n 一个例子熟练Print()函数的参数用法:\n1 2  with open(\u0026#39;abc.txt\u0026#39;,\u0026#39;w\u0026#39;) as f: print(\u0026#34;file\\n\u0026#34;,\u0026#34;abc\u0026#34;,\u0026#34;fff\u0026#34;,sep=\u0026#39;#########\\n\u0026#39;,end=\u0026#39;\u0026#39;,file=f)   运行，会输出以下内容到abc.txt中：\nfile ######### abc######### fff flush 参数默认为false，如果指定flush = True，那么会即时彻底执行print()函数，而不是先将内容存放在内存中。\n","permalink":"https://byteprince.com/posts/e5b64c32/","summary":"你真的懂 print() 的用法吗","title":"探索 Python 中的 print 函数"},{"content":"","permalink":"https://byteprince.com/photos/","summary":"","title":"我的相册"}]